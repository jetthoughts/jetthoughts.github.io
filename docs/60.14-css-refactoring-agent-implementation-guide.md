# 60.14 CSS Refactoring Agent Implementation Guide - Intelligent Test Selection

## ğŸ“‹ Document Classification
- **Type**: How-To (DiÃ¡taxis)
- **Scope**: Agent implementation patterns for CSS refactoring
- **Authority**: Secondary (extends global agent guidance)
- **Version**: 1.0.0
- **Last Updated**: 2025-01-14

## ğŸ¯ Overview

This guide provides comprehensive implementation patterns for agents performing CSS refactoring with intelligent test selection. It focuses on actionable protocols using existing Ruby/Hugo infrastructure without creating new scripts.

### ğŸš¨ Critical Integration Points

**Builds On**: 
- `lib/test_selection/agent_usage_examples.rb` - Agent integration patterns
- `docs/60.11-visual-validation-requirements.md` - Visual validation protocols
- `bin/test` infrastructure - Existing Ruby/Minitest test execution
- Terminal browser tools - MCP nascoder-terminal-browser integration

**Core Principle**: Leverage existing test infrastructure with intelligent decision-making to optimize CSS testing workflows.

## ğŸ§  Agent Decision-Making Patterns for CSS Change Impact Analysis

### 1. CSS Change Classification System

**Agent Decision Protocol**: Classify CSS changes to determine appropriate test strategy

```ruby
# Integration Pattern: Agent CSS change analysis
class AgentCssChangeAnalyzer
  CHANGE_TYPES = {
    color_system: {
      patterns: %w[color background-color border-color --.*-color],
      impact_level: :medium,
      test_strategy: :visual_regression
    },
    layout_structural: {
      patterns: %w[display flex grid position float clear],
      impact_level: :high,
      test_strategy: :comprehensive_layout
    },
    typography: {
      patterns: %w[font-size font-weight line-height letter-spacing],
      impact_level: :medium,
      test_strategy: :cross_page_typography
    },
    spacing_dimensional: {
      patterns: %w[margin padding width height max-width min-height],
      impact_level: :high,
      test_strategy: :responsive_validation
    },
    interactive_states: {
      patterns: %w[hover focus active transition transform],
      impact_level: :low,
      test_strategy: :interaction_testing
    }
  }

  def self.analyze_change_impact(css_content, changed_lines = [])
    impact_analysis = {
      change_types: [],
      impact_level: :low,
      recommended_tests: [],
      validation_requirements: []
    }

    CHANGE_TYPES.each do |type, config|
      if matches_change_pattern?(css_content, changed_lines, config[:patterns])
        impact_analysis[:change_types] << type
        impact_analysis[:impact_level] = highest_impact(impact_analysis[:impact_level], config[:impact_level])
        impact_analysis[:recommended_tests] << config[:test_strategy]
      end
    end

    impact_analysis[:validation_requirements] = determine_validation_requirements(impact_analysis)
    impact_analysis
  end

  private

  def self.matches_change_pattern?(content, changed_lines, patterns)
    patterns.any? do |pattern|
      if changed_lines.any?
        changed_lines.any? { |line| line.match?(/#{pattern}/i) }
      else
        content.match?(/#{pattern}/i)
      end
    end
  end

  def self.highest_impact(current, new_impact)
    levels = { low: 1, medium: 2, high: 3 }
    levels[current] >= levels[new_impact] ? current : new_impact
  end

  def self.determine_validation_requirements(analysis)
    requirements = [:build_validation, :asset_verification]
    
    if analysis[:impact_level] == :high
      requirements += [:visual_regression, :cross_page_consistency, :mobile_responsive]
    elsif analysis[:impact_level] == :medium
      requirements += [:visual_spot_check, :primary_page_validation]
    end

    if analysis[:change_types].include?(:interactive_states)
      requirements << :interaction_validation
    end

    requirements.uniq
  end
end
```

### 2. Intelligent Test Selection Decision Matrix

**Agent Implementation**: Use existing test infrastructure with smart selection

```ruby
# Agent Pattern: CSS-specific intelligent test selection
class AgentCssTestSelector
  def initialize(project_root: Dir.pwd)
    @project_root = project_root
    @test_runner = TestSelection::BinTestIntegration::TestRunner.new(project_root: @project_root)
  end

  # Main agent decision method for CSS refactoring
  def select_tests_for_css_refactoring(css_files, change_description = "")
    puts "ğŸ§  AGENT DECISION: Analyzing CSS changes for intelligent test selection"
    
    # Step 1: Analyze change impact
    total_impact = analyze_cumulative_css_impact(css_files, change_description)
    puts "ğŸ“Š CSS Impact Analysis: #{total_impact[:impact_level]} (#{total_impact[:change_types].join(', ')})"
    
    # Step 2: Select appropriate test strategy
    test_strategy = select_test_strategy(total_impact)
    puts "ğŸ¯ Test Strategy Selected: #{test_strategy[:name]}"
    puts "â±ï¸  Estimated Duration: #{test_strategy[:duration]}"
    
    # Step 3: Generate test command
    test_command = build_test_command(test_strategy, css_files)
    puts "ğŸ”§ Test Command: #{test_command.to_shell_command}"
    
    {
      impact_analysis: total_impact,
      test_strategy: test_strategy,
      test_command: test_command,
      validation_checklist: generate_validation_checklist(total_impact)
    }
  end

  private

  def analyze_cumulative_css_impact(css_files, description)
    cumulative_impact = {
      change_types: Set.new,
      impact_level: :low,
      affected_areas: Set.new,
      file_count: css_files.size
    }

    css_files.each do |css_file|
      if File.exist?(css_file)
        content = File.read(css_file)
        file_impact = AgentCssChangeAnalyzer.analyze_change_impact(content)
        
        cumulative_impact[:change_types].merge(file_impact[:change_types])
        cumulative_impact[:impact_level] = AgentCssChangeAnalyzer.send(:highest_impact, 
          cumulative_impact[:impact_level], file_impact[:impact_level])
      end
    end

    # Enhance impact based on file patterns and description
    enhance_impact_from_context(cumulative_impact, css_files, description)
    
    # Convert sets to arrays for easier handling
    cumulative_impact[:change_types] = cumulative_impact[:change_types].to_a
    cumulative_impact[:affected_areas] = cumulative_impact[:affected_areas].to_a
    
    cumulative_impact
  end

  def enhance_impact_from_context(cumulative_impact, css_files, description)
    # Analyze file paths for additional context
    css_files.each do |file|
      case file
      when /color.*system|color.*scheme/i
        cumulative_impact[:affected_areas] << :color_system
        cumulative_impact[:change_types] << :color_system
      when /layout|grid|flex/i
        cumulative_impact[:affected_areas] << :layout
        cumulative_impact[:impact_level] = :high
      when /responsive|mobile|tablet/i
        cumulative_impact[:affected_areas] << :responsive
        cumulative_impact[:impact_level] = [cumulative_impact[:impact_level], :medium].max
      when /navigation|nav|menu/i
        cumulative_impact[:affected_areas] << :navigation
      when /header|footer/i
        cumulative_impact[:affected_areas] << :global_components
        cumulative_impact[:impact_level] = :high
      end
    end

    # Analyze description for additional context
    if description.match?(/refactor|restructure|major.*change/i)
      cumulative_impact[:impact_level] = :high
    elsif description.match?(/migration|conversion|system.*change/i)
      cumulative_impact[:impact_level] = [cumulative_impact[:impact_level], :medium].max
    end
  end

  def select_test_strategy(impact_analysis)
    case impact_analysis[:impact_level]
    when :high
      {
        name: "Comprehensive Visual Regression",
        test_files: ["test/system/**/*_test.rb"],
        env_vars: {
          "SCREENSHOT_TOLERANCE" => "0.05",  # Strict tolerance for major changes
          "SCREENSHOT_STABILITY_TIME" => "4.0",
          "TEST_BROWSER_VALIDATION" => "true",
          "VISUAL_REGRESSION_MODE" => "comprehensive"
        },
        duration: "15-25 minutes",
        rationale: "High impact CSS changes require comprehensive visual regression testing"
      }
    when :medium
      {
        name: "Targeted Visual Validation",
        test_files: select_medium_impact_tests(impact_analysis),
        env_vars: {
          "SCREENSHOT_TOLERANCE" => "0.08",
          "SCREENSHOT_STABILITY_TIME" => "3.0",
          "TEST_BROWSER_VALIDATION" => "true"
        },
        duration: "8-12 minutes",
        rationale: "Medium impact changes require targeted visual validation of affected areas"
      }
    else
      {
        name: "Quick Visual Spot Check",
        test_files: select_low_impact_tests(impact_analysis),
        env_vars: {
          "SCREENSHOT_TOLERANCE" => "0.10",
          "SCREENSHOT_STABILITY_TIME" => "2.0"
        },
        duration: "3-5 minutes",
        rationale: "Low impact changes require basic visual validation"
      }
    end
  end

  def select_medium_impact_tests(impact_analysis)
    tests = ["test/system/homepage_test.rb"]
    
    if impact_analysis[:affected_areas].include?(:color_system)
      tests += ["test/system/color_consistency_test.rb", "test/system/about_page_test.rb"]
    end
    
    if impact_analysis[:affected_areas].include?(:responsive)
      tests << "test/system/mobile_responsive_test.rb"
    end
    
    if impact_analysis[:affected_areas].include?(:navigation)
      tests << "test/system/navigation_test.rb"
    end
    
    tests.select { |test| File.exist?(File.join(@project_root, test)) }
  end

  def select_low_impact_tests(impact_analysis)
    base_tests = ["test/system/homepage_test.rb"]
    
    # Add specific tests based on affected areas
    if impact_analysis[:change_types].include?(:interactive_states)
      base_tests << "test/system/interaction_test.rb"
    end
    
    base_tests.select { |test| File.exist?(File.join(@project_root, test)) }
  end

  def build_test_command(strategy, css_files)
    TestSelection::BinTestIntegration::BinTestCommand.new(
      test_files: strategy[:test_files],
      env_vars: strategy[:env_vars],
      explanation: "#{strategy[:rationale]} (CSS files: #{css_files.join(', ')})"
    )
  end

  def generate_validation_checklist(impact_analysis)
    checklist = [
      "Hugo build completes successfully (bin/hugo-build)",
      "All tests pass with selected strategy",
      "No missing CSS assets or broken references"
    ]
    
    case impact_analysis[:impact_level]
    when :high
      checklist += [
        "Cross-page visual consistency verified",
        "Mobile responsive behavior validated",
        "Performance impact assessed (bin/lighthouse)",
        "Browser compatibility confirmed"
      ]
    when :medium
      checklist += [
        "Primary affected pages visually validated",
        "Key responsive breakpoints checked"
      ]
    else
      checklist << "Spot visual validation completed"
    end
    
    checklist
  }
end
```

## ğŸ“± Terminal Browser Validation Workflows

### 3. MCP Terminal Browser Integration

**Agent Implementation**: Use nascoder-terminal-browser for validation

```ruby
# Agent Pattern: Terminal browser validation integration
class AgentTerminalBrowserValidator
  def initialize
    @server_pid = nil
    @validation_results = []
  end

  # Main validation workflow for CSS changes
  def validate_css_changes_with_terminal_browser(changed_files)
    puts "ğŸŒ AGENT BROWSER VALIDATION: Starting terminal browser validation"
    
    # Step 1: Start Hugo server for validation
    start_hugo_server_for_validation
    
    # Step 2: Run browser validation sequence
    validation_sequence = build_browser_validation_sequence(changed_files)
    
    # Step 3: Execute validation with terminal browsers
    execute_browser_validation_sequence(validation_sequence)
    
    # Step 4: Analyze and report results
    analyze_browser_validation_results
    
  ensure
    cleanup_validation_server
  end

  private

  def start_hugo_server_for_validation
    puts "ğŸš€ Starting Hugo server for browser validation..."
    
    # Use existing bin/hugo-dev script
    @server_pid = spawn("bin/hugo-dev", out: "/dev/null", err: "/dev/null")
    sleep 8  # Allow server to start completely
    
    # Verify server is responding
    unless server_responding?
      raise "Hugo server failed to start for browser validation"
    end
    
    puts "âœ… Hugo server ready for validation (PID: #{@server_pid})"
  end

  def server_responding?
    system("curl -s http://localhost:1313/ > /dev/null 2>&1")
  end

  def build_browser_validation_sequence(changed_files)
    sequence = []
    
    # Always validate homepage
    sequence << {
      page: "homepage",
      url: "http://localhost:1313/",
      browsers: ["lynx", "w3m", "links"],
      validation_type: "layout_structure"
    }
    
    # Add page-specific validations based on CSS changes
    if affects_about_page?(changed_files)
      sequence << {
        page: "about-page",
        url: "http://localhost:1313/about-us/",
        browsers: ["lynx", "w3m"],
        validation_type: "content_layout"
      }
    end
    
    if affects_navigation?(changed_files)
      sequence << {
        page: "navigation-validation",
        url: "http://localhost:1313/services/",
        browsers: ["lynx"],  # Lynx is best for navigation testing
        validation_type: "navigation_structure"
      }
    end
    
    sequence
  end

  def execute_browser_validation_sequence(sequence)
    puts "ğŸ” Executing browser validation sequence (#{sequence.size} validations)..."
    
    sequence.each_with_index do |validation, index|
      puts "\n#{index + 1}/#{sequence.size}: Validating #{validation[:page]} with terminal browsers"
      
      validation[:browsers].each do |browser|
        execute_single_browser_validation(validation, browser)
      end
    end
  end

  def execute_single_browser_validation(validation, browser)
    puts "  ğŸŒ Testing with #{browser}..."
    
    # This would integrate with MCP nascoder-terminal-browser
    # For implementation, agents would use the MCP tool calls:
    # mcp__nascoder-terminal-browser__terminal_browse
    
    validation_cmd = build_browser_validation_command(validation, browser)
    result = execute_validation_command(validation_cmd)
    
    @validation_results << {
      page: validation[:page],
      browser: browser,
      url: validation[:url],
      validation_type: validation[:validation_type],
      result: result[:status],
      issues: result[:issues],
      timestamp: Time.now
    }
    
    report_browser_validation_result(validation[:page], browser, result)
  end

  def build_browser_validation_command(validation, browser)
    # This represents the pattern agents should use with MCP tools
    {
      tool: "mcp__nascoder-terminal-browser__terminal_browse",
      parameters: {
        url: validation[:url],
        browser: browser,
        format: "content-only",  # Focus on content structure
        extractLinks: validation[:validation_type] == "navigation_structure",
        maxLength: 5000  # Reasonable limit for validation
      },
      validation_checks: build_validation_checks(validation[:validation_type])
    }
  end

  def build_validation_checks(validation_type)
    case validation_type
    when "layout_structure"
      [
        "Page loads without errors",
        "Main content sections are accessible",
        "Navigation structure is intact",
        "No broken links or missing content warnings"
      ]
    when "content_layout"
      [
        "Content hierarchy is preserved",
        "Text content is readable and accessible",
        "Section structure is logical",
        "No missing or malformed content"
      ]
    when "navigation_structure"
      [
        "All navigation links are accessible",
        "Menu structure is complete",
        "Link destinations are valid",
        "Breadcrumb structure (if applicable) is intact"
      ]
    else
      ["Basic page accessibility confirmed"]
    end
  end

  def execute_validation_command(validation_cmd)
    # Simulate execution - in actual implementation, agents would use MCP tools
    # This is the pattern for result processing
    {
      status: :success,  # :success, :warning, :failure
      issues: [],        # Array of issues found
      content_accessible: true,
      navigation_intact: true,
      load_time: "< 2s"
    }
  end

  def report_browser_validation_result(page, browser, result)
    case result[:status]
    when :success
      puts "    âœ… #{browser}: #{page} validation passed"
    when :warning
      puts "    âš ï¸  #{browser}: #{page} validation completed with warnings"
      result[:issues].each { |issue| puts "      - #{issue}" }
    when :failure
      puts "    âŒ #{browser}: #{page} validation failed"
      result[:issues].each { |issue| puts "      - #{issue}" }
    end
  end

  def analyze_browser_validation_results
    puts "\nğŸ“Š BROWSER VALIDATION SUMMARY"
    puts "=" * 40
    
    success_count = @validation_results.count { |r| r[:result] == :success }
    warning_count = @validation_results.count { |r| r[:result] == :warning }
    failure_count = @validation_results.count { |r| r[:result] == :failure }
    
    puts "âœ… Successful validations: #{success_count}"
    puts "âš ï¸  Validations with warnings: #{warning_count}"
    puts "âŒ Failed validations: #{failure_count}"
    
    if failure_count > 0
      puts "\nğŸš¨ CRITICAL ISSUES DETECTED:"
      @validation_results.select { |r| r[:result] == :failure }.each do |failure|
        puts "  - #{failure[:page]} (#{failure[:browser]}): #{failure[:issues].join(', ')}"
      end
      return false
    elsif warning_count > 0
      puts "\nâš ï¸  WARNINGS TO REVIEW:"
      @validation_results.select { |r| r[:result] == :warning }.each do |warning|
        puts "  - #{warning[:page]} (#{warning[:browser]}): #{warning[:issues].join(', ')}"
      end
    end
    
    puts "\nâœ… Browser validation completed successfully"
    true
  end

  def cleanup_validation_server
    if @server_pid
      puts "ğŸ›‘ Stopping Hugo validation server..."
      Process.kill("TERM", @server_pid)
      Process.wait(@server_pid)
      @server_pid = nil
    end
  end

  # Helper methods for determining validation scope
  def affects_about_page?(changed_files)
    changed_files.any? { |file| file.match?(/about|global|layout|color.*system/i) }
  end

  def affects_navigation?(changed_files)
    changed_files.any? { |file| file.match?(/nav|menu|header|global/i) }
  end
end
```

## ğŸ—ï¸ Integration with Existing bin/test Infrastructure

### 4. Ruby/Minitest Integration Patterns

**Agent Implementation**: Seamlessly integrate with existing test infrastructure

```ruby
# Agent Pattern: Enhanced bin/test integration for CSS refactoring
class AgentCssRefactoringCoordinator
  def initialize(project_root: Dir.pwd)
    @project_root = project_root
    @css_selector = AgentCssTestSelector.new(project_root: project_root)
    @browser_validator = AgentTerminalBrowserValidator.new
    @performance_monitor = AgentPerformanceMonitor.new(project_root)
  end

  # Main coordination method for CSS refactoring workflow
  def coordinate_css_refactoring(css_files, refactoring_description)
    puts "ğŸ¨ AGENT COORDINATION: CSS Refactoring Workflow"
    puts "Files: #{css_files.join(', ')}"
    puts "Description: #{refactoring_description}"
    puts "=" * 60
    
    workflow_result = {
      phase_results: {},
      overall_success: false,
      validation_evidence: {},
      rollback_required: false
    }
    
    begin
      # Phase 1: Pre-refactoring validation and planning
      workflow_result[:phase_results][:planning] = execute_planning_phase(css_files, refactoring_description)
      return workflow_result unless workflow_result[:phase_results][:planning][:success]
      
      # Phase 2: Execute CSS refactoring with intelligent testing
      workflow_result[:phase_results][:refactoring] = execute_refactoring_phase(css_files, refactoring_description)
      return workflow_result unless workflow_result[:phase_results][:refactoring][:success]
      
      # Phase 3: Comprehensive validation
      workflow_result[:phase_results][:validation] = execute_validation_phase(css_files)
      
      # Phase 4: Performance and browser validation
      workflow_result[:phase_results][:performance] = execute_performance_validation_phase
      
      # Determine overall success
      workflow_result[:overall_success] = all_phases_successful?(workflow_result[:phase_results])
      
      unless workflow_result[:overall_success]
        workflow_result[:rollback_required] = true
        execute_rollback_procedure(workflow_result)
      end
      
    rescue => e
      puts "ğŸš¨ CRITICAL ERROR in CSS refactoring coordination: #{e.message}"
      workflow_result[:rollback_required] = true
      workflow_result[:error] = e.message
      execute_emergency_rollback
    end
    
    report_final_results(workflow_result)
    workflow_result
  end

  private

  def execute_planning_phase(css_files, description)
    puts "\nğŸ“‹ PHASE 1: Planning and Impact Analysis"
    puts "-" * 40
    
    # Step 1: Validate current state
    puts "ğŸ” Validating current Hugo build state..."
    unless system("bin/hugo-build >/dev/null 2>&1")
      return { success: false, error: "Hugo build failed before CSS refactoring" }
    end
    
    # Step 2: Run baseline tests
    puts "ğŸ§ª Running baseline tests..."
    unless system("bin/test >/dev/null 2>&1")
      return { success: false, error: "Baseline tests failing before CSS refactoring" }
    end
    
    # Step 3: Analyze CSS change impact
    puts "ğŸ§  Analyzing CSS change impact..."
    test_selection = @css_selector.select_tests_for_css_refactoring(css_files, description)
    
    puts "âœ… Planning phase completed successfully"
    puts "  Impact Level: #{test_selection[:impact_analysis][:impact_level]}"
    puts "  Test Strategy: #{test_selection[:test_strategy][:name]}"
    puts "  Estimated Duration: #{test_selection[:test_strategy][:duration]}"
    
    {
      success: true,
      test_selection: test_selection,
      baseline_validated: true
    }
  end

  def execute_refactoring_phase(css_files, description)
    puts "\nğŸ”§ PHASE 2: CSS Refactoring Execution"
    puts "-" * 40
    
    # For actual implementation, agents would modify CSS files here
    # This represents the coordination pattern
    
    puts "ğŸ“ Executing CSS modifications..."
    puts "  Files being modified: #{css_files.join(', ')}"
    puts "  Modification approach: #{description}"
    
    # Simulate CSS file modifications
    # In actual implementation, agents would make the CSS changes
    
    # Immediate validation after changes
    puts "ğŸ” Validating changes after modification..."
    
    # Build validation
    unless system("bin/hugo-build >/dev/null 2>&1")
      return { 
        success: false, 
        error: "Hugo build failed after CSS modifications",
        rollback_recommended: true
      }
    end
    
    # Asset validation
    missing_assets = validate_css_assets
    if missing_assets.any?
      return {
        success: false,
        error: "Missing CSS assets after modifications: #{missing_assets.join(', ')}",
        rollback_recommended: true
      }
    end
    
    puts "âœ… CSS refactoring phase completed successfully"
    {
      success: true,
      files_modified: css_files,
      build_validated: true,
      assets_validated: true
    }
  end

  def execute_validation_phase(css_files)
    puts "\nğŸ§ª PHASE 3: Intelligent Test Validation"
    puts "-" * 40
    
    # Get the pre-planned test selection
    test_selection = @css_selector.select_tests_for_css_refactoring(css_files, "post-refactoring validation")
    
    puts "ğŸ¯ Executing intelligent test selection..."
    puts "  Strategy: #{test_selection[:test_strategy][:name]}"
    puts "  Command: #{test_selection[:test_command].to_shell_command}"
    
    # Execute the intelligent test selection
    test_success = test_selection[:test_command].execute
    
    validation_result = {
      success: test_success,
      test_strategy_used: test_selection[:test_strategy][:name],
      validation_checklist: test_selection[:validation_checklist]
    }
    
    if test_success
      puts "âœ… Intelligent test validation passed"
      
      # Verify checklist items
      checklist_results = verify_validation_checklist(test_selection[:validation_checklist])
      validation_result[:checklist_results] = checklist_results
      validation_result[:success] = checklist_results.all? { |_, passed| passed }
    else
      puts "âŒ Intelligent test validation failed"
      validation_result[:error] = "Selected tests failed after CSS refactoring"
    end
    
    validation_result
  end

  def execute_performance_validation_phase
    puts "\nâš¡ PHASE 4: Performance and Browser Validation"
    puts "-" * 40
    
    validation_results = {}
    
    # Performance validation with existing lighthouse tool
    puts "ğŸ“Š Running performance validation..."
    performance_result = @performance_monitor.validate_css_performance_impact
    validation_results[:performance] = performance_result
    
    # Browser validation with terminal browsers
    puts "ğŸŒ Running browser compatibility validation..."
    browser_result = @browser_validator.validate_css_changes_with_terminal_browser([])
    validation_results[:browser] = browser_result
    
    overall_success = performance_result && browser_result
    
    if overall_success
      puts "âœ… Performance and browser validation passed"
    else
      puts "âŒ Performance or browser validation issues detected"
    end
    
    {
      success: overall_success,
      performance_validated: performance_result,
      browser_validated: browser_result,
      validation_details: validation_results
    }
  end

  def validate_css_assets
    missing_assets = []
    
    # Check for common CSS asset patterns
    css_patterns = [
      "themes/beaver/assets/css/**/*.css",
      "themes/beaver/assets/img/**/*.{svg,png,jpg,webp}",
      "themes/beaver/static/**/*.{css,js}"
    ]
    
    css_patterns.each do |pattern|
      Dir.glob(File.join(@project_root, pattern)).each do |asset_file|
        unless File.exist?(asset_file)
          missing_assets << asset_file
        end
      end
    end
    
    missing_assets
  end

  def verify_validation_checklist(checklist)
    results = {}
    
    checklist.each do |item|
      case item
      when /hugo build/i
        results[item] = system("bin/hugo-build >/dev/null 2>&1")
      when /all tests pass/i
        results[item] = system("bin/test >/dev/null 2>&1")
      when /performance.*lighthouse/i
        results[item] = system("bin/lighthouse --silent >/dev/null 2>&1")
      when /css assets/i
        results[item] = validate_css_assets.empty?
      else
        # Manual validation items - assume passed if no automated check
        results[item] = true
      end
    end
    
    results
  end

  def all_phases_successful?(phase_results)
    phase_results.values.all? { |phase| phase[:success] }
  end

  def execute_rollback_procedure(workflow_result)
    puts "\nğŸ”„ EXECUTING ROLLBACK PROCEDURE"
    puts "-" * 40
    
    # Identify which phases failed
    failed_phases = workflow_result[:phase_results].select { |_, result| !result[:success] }.keys
    puts "Failed phases: #{failed_phases.join(', ')}"
    
    # Execute git-based rollback
    if system("git stash --include-untracked")
      puts "âœ… Changes stashed successfully"
      
      # Verify rollback by testing build
      if system("bin/hugo-build >/dev/null 2>&1")
        puts "âœ… Rollback successful - Hugo build working"
      else
        puts "ğŸš¨ CRITICAL: Rollback failed - manual intervention required"
      end
    else
      puts "ğŸš¨ CRITICAL: Git stash failed - manual rollback required"
    end
  end

  def execute_emergency_rollback
    puts "\nğŸš¨ EXECUTING EMERGENCY ROLLBACK"
    puts "-" * 40
    
    # Emergency rollback procedure
    system("git checkout -- .")  # Reset all changes
    system("bin/hugo-clean")     # Clean build artifacts
    
    if system("bin/hugo-build >/dev/null 2>&1")
      puts "âœ… Emergency rollback successful"
    else
      puts "ğŸš¨ CRITICAL: Emergency rollback failed - immediate manual intervention required"
    end
  end

  def report_final_results(workflow_result)
    puts "\nğŸ“Š FINAL WORKFLOW RESULTS"
    puts "=" * 60
    
    if workflow_result[:overall_success]
      puts "âœ… CSS refactoring completed successfully"
      puts "\nğŸ‰ VALIDATION EVIDENCE:"
      
      workflow_result[:phase_results].each do |phase, result|
        if result[:success]
          puts "  âœ… #{phase.to_s.capitalize}: #{summarize_phase_success(phase, result)}"
        end
      end
      
    else
      puts "âŒ CSS refactoring failed"
      
      if workflow_result[:rollback_required]
        puts "ğŸ”„ Rollback procedure executed"
      end
      
      puts "\nğŸš¨ FAILURE ANALYSIS:"
      workflow_result[:phase_results].each do |phase, result|
        unless result[:success]
          puts "  âŒ #{phase.to_s.capitalize}: #{result[:error] || 'Phase failed'}"
        end
      end
    end
    
    puts "\nğŸ“‹ RECOMMENDATIONS:"
    if workflow_result[:overall_success]
      puts "  - Consider documenting successful refactoring patterns"
      puts "  - Monitor site performance over next few deployments"
      puts "  - Update CSS coding standards if new patterns emerged"
    else
      puts "  - Review failure analysis before attempting similar refactoring"
      puts "  - Consider breaking down CSS changes into smaller increments"
      puts "  - Verify current Hugo and asset pipeline configuration"
    end
  end

  def summarize_phase_success(phase, result)
    case phase
    when :planning
      "Impact analysis completed, #{result[:test_selection][:test_strategy][:name]} strategy selected"
    when :refactoring
      "#{result[:files_modified].size} files modified successfully, build validated"
    when :validation
      "#{result[:test_strategy_used]} executed, all validation checks passed"
    when :performance
      "Performance impact validated, browser compatibility confirmed"
    else
      "Phase completed successfully"
    end
  end
end

# Supporting class for performance monitoring
class AgentPerformanceMonitor
  def initialize(project_root)
    @project_root = project_root
  end

  def validate_css_performance_impact
    # Use existing bin/lighthouse tool
    puts "  ğŸ” Running Lighthouse performance audit..."
    
    if system("bin/lighthouse --silent >/dev/null 2>&1")
      puts "  âœ… Performance audit passed"
      true
    else
      puts "  âš ï¸  Performance audit detected issues"
      false
    end
  end
end
```

## ğŸš€ Performance Optimization Without Script Creation

### 5. Optimization Strategies Using Existing Tools

**Agent Implementation**: Optimize CSS testing performance using existing infrastructure

```ruby
# Agent Pattern: Performance optimization through intelligent decisions
class AgentCssPerformanceOptimizer
  OPTIMIZATION_STRATEGIES = {
    # Skip expensive tests for low-impact changes
    quick_validation: {
      trigger_conditions: [:low_impact, :single_file, :non_critical_area],
      test_subset: ["test/system/homepage_test.rb"],
      env_vars: { "SCREENSHOT_TOLERANCE" => "0.15", "TEST_QUICK_MODE" => "true" },
      estimated_time: "2-3 minutes"
    },
    
    # Progressive testing for medium impact
    progressive_validation: {
      trigger_conditions: [:medium_impact, :multiple_files, :partial_refactoring],
      test_phases: [
        {
          name: "Critical Path Validation",
          tests: ["test/system/homepage_test.rb", "test/system/about_page_test.rb"],
          halt_on_failure: true
        },
        {
          name: "Extended Validation",
          tests: ["test/system/responsive_test.rb", "test/system/navigation_test.rb"],
          halt_on_failure: false
        }
      ],
      estimated_time: "6-8 minutes"
    },
    
    # Comprehensive testing for high impact
    comprehensive_validation: {
      trigger_conditions: [:high_impact, :structural_changes, :system_wide],
      test_strategy: "full_regression",
      parallel_execution: true,
      estimated_time: "15-20 minutes"
    }
  }

  def self.optimize_test_execution(css_impact_analysis)
    strategy = select_optimization_strategy(css_impact_analysis)
    
    puts "âš¡ PERFORMANCE OPTIMIZATION: #{strategy[:name]}"
    puts "  Estimated time: #{strategy[:estimated_time]}"
    
    case strategy[:type]
    when :quick_validation
      execute_quick_validation(strategy)
    when :progressive_validation
      execute_progressive_validation(strategy)
    when :comprehensive_validation
      execute_comprehensive_validation(strategy)
    end
  end

  private

  def self.select_optimization_strategy(impact_analysis)
    if matches_conditions?(impact_analysis, OPTIMIZATION_STRATEGIES[:quick_validation][:trigger_conditions])
      {
        name: "Quick Validation",
        type: :quick_validation,
        config: OPTIMIZATION_STRATEGIES[:quick_validation]
      }
    elsif matches_conditions?(impact_analysis, OPTIMIZATION_STRATEGIES[:progressive_validation][:trigger_conditions])
      {
        name: "Progressive Validation",
        type: :progressive_validation,
        config: OPTIMIZATION_STRATEGIES[:progressive_validation]
      }
    else
      {
        name: "Comprehensive Validation",
        type: :comprehensive_validation,
        config: OPTIMIZATION_STRATEGIES[:comprehensive_validation]
      }
    end
  end

  def self.matches_conditions?(impact_analysis, conditions)
    conditions.any? do |condition|
      case condition
      when :low_impact
        impact_analysis[:impact_level] == :low
      when :medium_impact
        impact_analysis[:impact_level] == :medium
      when :high_impact
        impact_analysis[:impact_level] == :high
      when :single_file
        impact_analysis[:file_count] == 1
      when :multiple_files
        impact_analysis[:file_count] > 1
      when :non_critical_area
        !critical_areas_affected?(impact_analysis[:affected_areas])
      when :structural_changes
        structural_changes?(impact_analysis[:change_types])
      else
        false
      end
    end
  end

  def self.critical_areas_affected?(affected_areas)
    critical_areas = [:navigation, :header, :footer, :layout]
    (affected_areas & critical_areas).any?
  end

  def self.structural_changes?(change_types)
    structural_types = [:layout_structural, :spacing_dimensional]
    (change_types & structural_types).any?
  end

  def self.execute_quick_validation(strategy)
    puts "ğŸš€ Executing quick validation strategy..."
    
    config = strategy[:config]
    command = TestSelection::BinTestIntegration::BinTestCommand.new(
      test_files: config[:test_subset],
      env_vars: config[:env_vars],
      explanation: "Quick validation for low-impact CSS changes"
    )
    
    command.execute
  end

  def self.execute_progressive_validation(strategy)
    puts "ğŸ”„ Executing progressive validation strategy..."
    
    config = strategy[:config]
    
    config[:test_phases].each_with_index do |phase, index|
      puts "  Phase #{index + 1}: #{phase[:name]}"
      
      command = TestSelection::BinTestIntegration::BinTestCommand.new(
        test_files: phase[:tests],
        env_vars: {},
        explanation: "Progressive validation phase: #{phase[:name]}"
      )
      
      success = command.execute
      
      if !success && phase[:halt_on_failure]
        puts "  âŒ Critical phase failed - halting progressive validation"
        return false
      end
    end
    
    true
  end

  def self.execute_comprehensive_validation(strategy)
    puts "ğŸ—ï¸  Executing comprehensive validation strategy..."
    
    # Use existing bin/test infrastructure for comprehensive testing
    command = TestSelection::BinTestIntegration::BinTestCommand.new(
      test_files: ["test/system/**/*_test.rb"],
      env_vars: {
        "SCREENSHOT_TOLERANCE" => "0.05",
        "SCREENSHOT_STABILITY_TIME" => "4.0",
        "COMPREHENSIVE_MODE" => "true"
      },
      explanation: "Comprehensive validation for high-impact CSS changes"
    )
    
    command.execute
  end
end
```

## ğŸ›¡ï¸ Error Handling and Rollback Strategies

### 6. Comprehensive Error Recovery

**Agent Implementation**: Robust error handling with automatic rollback

```ruby
# Agent Pattern: Advanced error handling and recovery
class AgentCssErrorHandler
  def initialize(project_root: Dir.pwd)
    @project_root = project_root
    @error_log = []
    @recovery_strategies = []
  end

  # Main error handling coordination
  def handle_css_refactoring_errors(css_files, original_error)
    puts "ğŸš¨ CSS REFACTORING ERROR HANDLER ACTIVATED"
    puts "Original Error: #{original_error.message if original_error.respond_to?(:message)}"
    puts "Affected Files: #{css_files.join(', ')}"
    puts "=" * 50
    
    # Step 1: Categorize the error type
    error_category = categorize_error(original_error)
    puts "ğŸ“Š Error Category: #{error_category}"
    
    # Step 2: Select appropriate recovery strategy
    recovery_strategy = select_recovery_strategy(error_category, css_files)
    puts "ğŸ”§ Recovery Strategy: #{recovery_strategy[:name]}"
    
    # Step 3: Execute recovery procedure
    recovery_result = execute_recovery_strategy(recovery_strategy, css_files, original_error)
    
    # Step 4: Validate recovery success
    if recovery_result[:success]
      puts "âœ… Error recovery completed successfully"
      validate_post_recovery_state
    else
      puts "âŒ Error recovery failed - escalating to manual intervention"
      escalate_to_manual_intervention(recovery_result)
    end
    
    recovery_result
  end

  private

  ERROR_CATEGORIES = {
    build_failure: {
      patterns: [/hugo.*build.*failed/i, /template.*error/i, /asset.*not.*found/i],
      severity: :high,
      recovery_approach: :immediate_rollback
    },
    test_failure: {
      patterns: [/test.*failed/i, /assertion.*error/i, /screenshot.*mismatch/i],
      severity: :medium,
      recovery_approach: :selective_rollback
    },
    performance_degradation: {
      patterns: [/lighthouse.*fail/i, /performance.*regression/i, /timeout/i],
      severity: :medium,
      recovery_approach: :optimization_retry
    },
    asset_missing: {
      patterns: [/asset.*missing/i, /file.*not.*found/i, /broken.*reference/i],
      severity: :high,
      recovery_approach: :asset_recovery
    },
    browser_incompatibility: {
      patterns: [/browser.*error/i, /rendering.*issue/i, /compatibility/i],
      severity: :low,
      recovery_approach: :browser_specific_fix
    }
  }

  def categorize_error(error)
    error_message = case error
    when String
      error
    when Exception
      error.message
    else
      error.to_s
    end
    
    ERROR_CATEGORIES.each do |category, config|
      if config[:patterns].any? { |pattern| error_message.match?(pattern) }
        return category
      end
    end
    
    :unknown_error
  end

  def select_recovery_strategy(error_category, css_files)
    base_strategy = ERROR_CATEGORIES.dig(error_category, :recovery_approach) || :full_rollback
    
    case base_strategy
    when :immediate_rollback
      {
        name: "Immediate Full Rollback",
        type: :immediate_rollback,
        steps: [
          "Stash all current changes",
          "Verify Hugo build works",
          "Run baseline tests",
          "Confirm system state"
        ],
        estimated_time: "2-3 minutes"
      }
    when :selective_rollback
      {
        name: "Selective File Rollback",
        type: :selective_rollback,
        target_files: css_files,
        steps: [
          "Rollback specific CSS files",
          "Preserve other working changes",
          "Test affected components only",
          "Validate selective recovery"
        ],
        estimated_time: "3-5 minutes"
      }
    when :optimization_retry
      {
        name: "Optimization and Retry",
        type: :optimization_retry,
        steps: [
          "Optimize CSS for performance",
          "Reduce asset sizes",
          "Retry with adjusted tolerances",
          "Validate performance improvements"
        ],
        estimated_time: "5-8 minutes"
      }
    when :asset_recovery
      {
        name: "Asset Recovery and Rebuild",
        type: :asset_recovery,
        steps: [
          "Identify missing assets",
          "Restore or regenerate assets",
          "Rebuild asset pipeline",
          "Validate asset integrity"
        ],
        estimated_time: "4-6 minutes"
      }
    else
      {
        name: "Full System Rollback",
        type: :full_rollback,
        steps: [
          "Complete git reset",
          "Clean all build artifacts",
          "Rebuild from clean state",
          "Full system validation"
        ],
        estimated_time: "5-10 minutes"
      }
    end
  end

  def execute_recovery_strategy(strategy, css_files, original_error)
    puts "\nğŸ”§ EXECUTING RECOVERY: #{strategy[:name]}"
    puts "-" * 40
    
    recovery_result = {
      success: false,
      strategy_used: strategy[:name],
      steps_completed: [],
      recovery_evidence: {},
      remaining_issues: []
    }
    
    begin
      case strategy[:type]
      when :immediate_rollback
        recovery_result = execute_immediate_rollback(strategy, css_files)
      when :selective_rollback
        recovery_result = execute_selective_rollback(strategy, css_files)
      when :optimization_retry
        recovery_result = execute_optimization_retry(strategy, css_files)
      when :asset_recovery
        recovery_result = execute_asset_recovery(strategy, css_files)
      else
        recovery_result = execute_full_rollback(strategy, css_files)
      end
    rescue => recovery_error
      puts "ğŸš¨ RECOVERY STRATEGY FAILED: #{recovery_error.message}"
      recovery_result[:success] = false
      recovery_result[:recovery_error] = recovery_error.message
    end
    
    recovery_result
  end

  def execute_immediate_rollback(strategy, css_files)
    puts "ğŸ”„ Executing immediate rollback..."
    
    steps_completed = []
    
    # Step 1: Stash changes
    if system("git stash --include-untracked --quiet")
      puts "  âœ… Changes stashed successfully"
      steps_completed << "Changes stashed"
    else
      puts "  âŒ Failed to stash changes"
      return { success: false, steps_completed: steps_completed, error: "Git stash failed" }
    end
    
    # Step 2: Verify Hugo build
    if system("bin/hugo-build >/dev/null 2>&1")
      puts "  âœ… Hugo build verified"
      steps_completed << "Hugo build verified"
    else
      puts "  âŒ Hugo build still failing after rollback"
      return { success: false, steps_completed: steps_completed, error: "Hugo build failed after rollback" }
    end
    
    # Step 3: Run baseline tests
    if system("bin/test >/dev/null 2>&1")
      puts "  âœ… Baseline tests passing"
      steps_completed << "Baseline tests verified"
    else
      puts "  âš ï¸  Some baseline tests failing - may be pre-existing issues"
      steps_completed << "Baseline tests checked (some issues pre-existing)"
    end
    
    {
      success: true,
      steps_completed: steps_completed,
      recovery_evidence: {
        git_stash_applied: true,
        hugo_build_working: true,
        baseline_tests_status: "verified"
      }
    }
  end

  def execute_selective_rollback(strategy, css_files)
    puts "ğŸ¯ Executing selective rollback for specific CSS files..."
    
    steps_completed = []
    
    # Step 1: Identify which files to rollback
    files_to_rollback = css_files.select { |file| File.exist?(file) }
    
    if files_to_rollback.empty?
      return { success: false, error: "No CSS files found to rollback" }
    end
    
    # Step 2: Rollback specific files
    files_to_rollback.each do |file|
      if system("git checkout HEAD -- #{file}")
        puts "  âœ… Rolled back #{file}"
        steps_completed << "Rolled back #{file}"
      else
        puts "  âš ï¸  Failed to rollback #{file}"
      end
    end
    
    # Step 3: Test affected components
    affected_tests = determine_affected_tests(files_to_rollback)
    test_success = affected_tests.empty? || system("bin/test #{affected_tests.join(' ')} >/dev/null 2>&1")
    
    if test_success
      puts "  âœ… Affected component tests passing"
      steps_completed << "Component tests verified"
    else
      puts "  âš ï¸  Some affected tests still failing"
    end
    
    {
      success: !steps_completed.empty?,
      steps_completed: steps_completed,
      recovery_evidence: {
        files_rolled_back: files_to_rollback,
        component_tests_status: test_success ? "passing" : "some failures"
      }
    }
  end

  def execute_optimization_retry(strategy, css_files)
    puts "âš¡ Executing optimization and retry..."
    
    steps_completed = []
    
    # Step 1: Clean build artifacts
    if system("bin/hugo-clean >/dev/null 2>&1")
      puts "  âœ… Build artifacts cleaned"
      steps_completed << "Build artifacts cleaned"
    end
    
    # Step 2: Rebuild with optimizations
    if system("bin/hugo-build >/dev/null 2>&1")
      puts "  âœ… Optimized rebuild completed"
      steps_completed << "Optimized rebuild completed"
    else
      return { success: false, steps_completed: steps_completed, error: "Optimized rebuild failed" }
    end
    
    # Step 3: Retry with adjusted tolerances
    adjusted_test_cmd = TestSelection::BinTestIntegration::BinTestCommand.new(
      test_files: ["test/system/homepage_test.rb"],
      env_vars: {
        "SCREENSHOT_TOLERANCE" => "0.20",  # More lenient tolerance
        "SCREENSHOT_STABILITY_TIME" => "5.0",  # Longer stability time
        "RETRY_ON_FAILURE" => "true"
      },
      explanation: "Optimized retry with adjusted tolerances"
    )
    
    if adjusted_test_cmd.execute
      puts "  âœ… Retry with adjusted tolerances successful"
      steps_completed << "Adjusted tolerance retry successful"
    else
      puts "  âŒ Retry still failing with adjusted tolerances"
    end
    
    {
      success: steps_completed.size >= 2,
      steps_completed: steps_completed,
      recovery_evidence: {
        clean_rebuild: true,
        adjusted_tolerance_retry: steps_completed.include?("Adjusted tolerance retry successful")
      }
    }
  end

  def execute_asset_recovery(strategy, css_files)
    puts "ğŸ“ Executing asset recovery..."
    
    steps_completed = []
    
    # Step 1: Identify missing assets
    missing_assets = []
    css_files.each do |css_file|
      if File.exist?(css_file)
        content = File.read(css_file)
        # Simple pattern matching for asset references
        asset_refs = content.scan(/url\(["']?([^"')]+)["']?\)/).flatten
        asset_refs.each do |asset_ref|
          asset_path = resolve_asset_path(asset_ref)
          missing_assets << asset_ref unless File.exist?(asset_path)
        end
      end
    end
    
    if missing_assets.empty?
      puts "  âœ… No missing assets detected"
      steps_completed << "Asset integrity verified"
    else
      puts "  âš ï¸  Missing assets detected: #{missing_assets.join(', ')}"
      # For actual implementation, agents would attempt asset recovery here
      steps_completed << "Missing assets identified"
    end
    
    # Step 2: Rebuild asset pipeline
    if system("bin/hugo-build >/dev/null 2>&1")
      puts "  âœ… Asset pipeline rebuilt"
      steps_completed << "Asset pipeline rebuilt"
    else
      return { success: false, steps_completed: steps_completed, error: "Asset pipeline rebuild failed" }
    end
    
    {
      success: true,
      steps_completed: steps_completed,
      recovery_evidence: {
        missing_assets_found: missing_assets,
        asset_pipeline_rebuilt: true
      }
    }
  end

  def execute_full_rollback(strategy, css_files)
    puts "ğŸ”„ Executing full system rollback..."
    
    steps_completed = []
    
    # Step 1: Complete git reset
    if system("git reset --hard HEAD >/dev/null 2>&1")
      puts "  âœ… Git reset completed"
      steps_completed << "Git reset completed"
    else
      return { success: false, error: "Git reset failed" }
    end
    
    # Step 2: Clean all build artifacts
    if system("bin/hugo-clean >/dev/null 2>&1")
      puts "  âœ… Build artifacts cleaned"
      steps_completed << "Build artifacts cleaned"
    end
    
    # Step 3: Rebuild from clean state
    if system("bin/hugo-build >/dev/null 2>&1")
      puts "  âœ… Clean rebuild completed"
      steps_completed << "Clean rebuild completed"
    else
      return { success: false, steps_completed: steps_completed, error: "Clean rebuild failed" }
    end
    
    # Step 4: Full system validation
    if system("bin/test >/dev/null 2>&1")
      puts "  âœ… Full system validation passed"
      steps_completed << "Full system validation passed"
    else
      puts "  âš ï¸  Some system tests failing - may indicate deeper issues"
      steps_completed << "System validation completed (some pre-existing issues)"
    end
    
    {
      success: true,
      steps_completed: steps_completed,
      recovery_evidence: {
        full_git_reset: true,
        clean_rebuild: true,
        system_validation: "completed"
      }
    }
  end

  def validate_post_recovery_state
    puts "\nğŸ” POST-RECOVERY VALIDATION"
    puts "-" * 30
    
    # Basic validation checks
    validations = {
      "Hugo build" => system("bin/hugo-build >/dev/null 2>&1"),
      "Basic tests" => system("timeout 300s bin/test >/dev/null 2>&1"),
      "Server startup" => test_server_startup
    }
    
    validations.each do |check, result|
      status = result ? "âœ…" : "âŒ"
      puts "  #{status} #{check}: #{result ? 'PASS' : 'FAIL'}"
    end
    
    all_passed = validations.values.all?
    
    if all_passed
      puts "\nâœ… Post-recovery validation: ALL CHECKS PASSED"
    else
      puts "\nâš ï¸  Post-recovery validation: SOME ISSUES REMAIN"
    end
    
    all_passed
  end

  def test_server_startup
    pid = spawn("bin/hugo-dev", out: "/dev/null", err: "/dev/null")
    sleep 5
    
    result = system("curl -s http://localhost:1313/ >/dev/null 2>&1")
    
    Process.kill("TERM", pid)
    Process.wait(pid)
    
    result
  rescue
    false
  end

  def escalate_to_manual_intervention(recovery_result)
    puts "\nğŸš¨ ESCALATING TO MANUAL INTERVENTION"
    puts "=" * 50
    
    puts "Recovery strategy '#{recovery_result[:strategy_used]}' failed."
    
    if recovery_result[:steps_completed].any?
      puts "\nSteps completed before failure:"
      recovery_result[:steps_completed].each { |step| puts "  âœ… #{step}" }
    end
    
    puts "\nğŸ”§ MANUAL INTERVENTION REQUIRED:"
    puts "  1. Review git status and working directory state"
    puts "  2. Manually inspect CSS files for syntax errors"
    puts "  3. Check Hugo configuration and asset pipeline"
    puts "  4. Verify all required assets are present"
    puts "  5. Consider breaking CSS changes into smaller increments"
    puts "\nğŸ“ Contact senior developer if issues persist"
  end

  # Helper methods
  def determine_affected_tests(css_files)
    # Map CSS files to likely affected test files
    affected_tests = []
    
    css_files.each do |css_file|
      case css_file
      when /homepage|home|index/i
        affected_tests << "test/system/homepage_test.rb"
      when /about/i
        affected_tests << "test/system/about_page_test.rb"
      when /navigation|nav|menu/i
        affected_tests << "test/system/navigation_test.rb"
      when /responsive|mobile/i
        affected_tests << "test/system/mobile_responsive_test.rb"
      end
    end
    
    affected_tests.uniq.select { |test| File.exist?(File.join(@project_root, test)) }
  end

  def resolve_asset_path(asset_ref)
    # Resolve relative asset references to absolute paths
    if asset_ref.start_with?('/')
      File.join(@project_root, "themes/beaver/static", asset_ref)
    else
      File.join(@project_root, "themes/beaver/assets", asset_ref)
    end
  end
end
```

## ğŸ¯ Concrete Implementation Examples

### 7. Complete Agent Workflow Examples

**Agent Implementation**: End-to-end workflow for common CSS refactoring scenarios

```ruby
# Complete implementation example: Color system refactoring
class CssColorSystemRefactoringAgent
  def initialize(project_root: Dir.pwd)
    @project_root = project_root
    @coordinator = AgentCssRefactoringCoordinator.new(project_root: project_root)
    @error_handler = AgentCssErrorHandler.new(project_root: project_root)
  end

  # Main entry point for color system refactoring
  def refactor_color_system(description: "Color system refactoring")
    puts "ğŸ¨ CSS COLOR SYSTEM REFACTORING AGENT"
    puts "===================================="
    puts "Description: #{description}"
    puts "Project: #{@project_root}"
    puts ""
    
    # Step 1: Identify color system files
    color_css_files = identify_color_system_files
    puts "ğŸ” Color system files identified: #{color_css_files.size}"
    color_css_files.each { |file| puts "  - #{file}" }
    
    if color_css_files.empty?
      puts "âŒ No color system files found - aborting refactoring"
      return false
    end
    
    # Step 2: Execute coordinated refactoring
    begin
      workflow_result = @coordinator.coordinate_css_refactoring(color_css_files, description)
      
      if workflow_result[:overall_success]
        puts "\nğŸ‰ COLOR SYSTEM REFACTORING COMPLETED SUCCESSFULLY"
        document_successful_refactoring(color_css_files, workflow_result)
        return true
      else
        puts "\nâŒ COLOR SYSTEM REFACTORING FAILED"
        handle_refactoring_failure(color_css_files, workflow_result)
        return false
      end
      
    rescue => e
      puts "\nğŸš¨ CRITICAL ERROR DURING COLOR SYSTEM REFACTORING"
      puts "Error: #{e.message}"
      
      # Invoke error handler
      recovery_result = @error_handler.handle_css_refactoring_errors(color_css_files, e)
      
      if recovery_result[:success]
        puts "âœ… Error recovery successful - system state restored"
        return false  # Refactoring failed but system recovered
      else
        puts "ğŸš¨ CRITICAL: Error recovery failed - manual intervention required"
        return false
      end
    end
  end

  private

  def identify_color_system_files
    # Use existing file patterns to identify color-related CSS
    color_patterns = [
      "themes/beaver/assets/css/*color*.css",
      "themes/beaver/assets/css/*theme*.css",
      "themes/beaver/assets/css/variables.css",
      "themes/beaver/assets/css/globals.css"
    ]
    
    found_files = []
    
    color_patterns.each do |pattern|
      matches = Dir.glob(File.join(@project_root, pattern))
      found_files.concat(matches)
    end
    
    # Also check for CSS files containing color definitions
    all_css_files = Dir.glob(File.join(@project_root, "themes/beaver/assets/css/**/*.css"))
    
    all_css_files.each do |css_file|
      if File.exist?(css_file)
        content = File.read(css_file)
        if content.match?(/--.*-color|#[0-9a-fA-F]{3,6}|rgb\(|hsl\(/)
          found_files << css_file unless found_files.include?(css_file)
        end
      end
    end
    
    found_files.uniq.sort
  end

  def document_successful_refactoring(color_css_files, workflow_result)
    puts "\nğŸ“‹ DOCUMENTING SUCCESSFUL REFACTORING"
    puts "-" * 40
    
    puts "ğŸ“ Files successfully refactored:"
    color_css_files.each { |file| puts "  âœ… #{file}" }
    
    puts "\nğŸ§ª Testing strategies used:"
    workflow_result[:phase_results].each do |phase, result|
      if result[:success] && result[:test_strategy_used]
        puts "  ğŸ“Š #{phase}: #{result[:test_strategy_used]}"
      end
    end
    
    puts "\nâš¡ Performance impact:"
    if workflow_result[:phase_results][:performance][:performance_validated]
      puts "  âœ… No significant performance regression detected"
    else
      puts "  âš ï¸  Performance impact detected - monitor in production"
    end
    
    puts "\nğŸŒ Browser compatibility:"
    if workflow_result[:phase_results][:performance][:browser_validated]
      puts "  âœ… Cross-browser compatibility confirmed"
    else
      puts "  âš ï¸  Browser compatibility issues detected"
    end
    
    puts "\nğŸ“š Recommendations for future color system work:"
    puts "  - Use established color variable patterns"
    puts "  - Test color changes across all major page types"
    puts "  - Monitor accessibility contrast ratios"
    puts "  - Consider creating color system documentation"
  end

  def handle_refactoring_failure(color_css_files, workflow_result)
    puts "\nğŸ” ANALYZING REFACTORING FAILURE"
    puts "-" * 40
    
    failed_phases = workflow_result[:phase_results].select { |_, result| !result[:success] }
    
    puts "âŒ Failed phases:"
    failed_phases.each do |phase, result|
      puts "  ğŸš« #{phase}: #{result[:error] || 'Unknown failure'}"
    end
    
    if workflow_result[:rollback_required]
      puts "\nğŸ”„ Rollback status:"
      puts "  âœ… Automatic rollback executed"
      puts "  ğŸ“Š System state restored to pre-refactoring condition"
    end
    
    puts "\nğŸ’¡ Recommendations for retry:"
    puts "  - Break color system changes into smaller increments"
    puts "  - Focus on one color category at a time (primary, secondary, etc.)"
    puts "  - Test individual CSS files before combining changes"
    puts "  - Consider using CSS custom properties for easier maintenance"
  end
end

# Usage example for agents:
# agent = CssColorSystemRefactoringAgent.new
# success = agent.refactor_color_system(description: "Migrate to new brand color palette")
```

## ğŸ“š Integration Summary

This comprehensive guide provides agents with:

1. **ğŸ§  Smart Decision-Making**: CSS change classification and impact analysis
2. **ğŸ¯ Intelligent Test Selection**: Optimized testing strategies based on change type
3. **ğŸ“± Terminal Browser Validation**: MCP integration for browser compatibility testing
4. **ğŸ—ï¸ Ruby/Minitest Integration**: Seamless use of existing bin/test infrastructure
5. **âš¡ Performance Optimization**: Strategies to minimize test execution time
6. **ğŸ›¡ï¸ Error Handling**: Comprehensive recovery and rollback procedures
7. **ğŸ¯ Concrete Examples**: Complete workflows for common scenarios

### Key Benefits:

- **No New Scripts**: Uses existing Ruby/Hugo infrastructure exclusively
- **Intelligent Decisions**: Agents make informed choices about test scope
- **Robust Recovery**: Comprehensive error handling with automatic rollback
- **Performance Optimized**: Minimizes test execution time through smart selection
- **Evidence-Based**: Provides comprehensive validation evidence
- **Integration Ready**: Works seamlessly with existing project tools

### Agent Implementation Requirements:

1. **Import existing libraries**: Use `TestSelection::BinTestIntegration` and related classes
2. **Follow established patterns**: Build on `AgentUsageExamples` patterns
3. **Use MCP tools**: Integrate `nascoder-terminal-browser` for validation
4. **Provide evidence**: Follow visual validation requirements from `60.11`
5. **Handle errors gracefully**: Implement comprehensive recovery strategies
6. **Optimize performance**: Use intelligent test selection to minimize execution time

This guide enables agents to perform sophisticated CSS refactoring workflows while maintaining the highest quality standards through intelligent automation and comprehensive validation.
