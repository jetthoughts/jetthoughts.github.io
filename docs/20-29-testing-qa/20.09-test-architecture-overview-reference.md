# Test Architecture Overview

**Docker Compose + Hugo In-Memory Rendering System**

## Executive Summary

This document outlines a comprehensive test architecture that combines Docker Compose orchestration with Hugo's in-memory rendering capabilities to achieve optimal testing performance while maintaining isolation and reproducibility.

### Key Performance Targets

- **Syntax Check**: <1s - Hugo build --dryRun
- **Memory Tests**: <3s - In-memory content validation  
- **Quick Tests**: <10s - Changed files only
- **Full Tests**: <60s - Complete validation

## Architecture Philosophy

### Core Principles

1. **Layered Validation**: Multiple tiers with increasing scope and time investment
2. **Fail-Fast Strategy**: Quick feedback for common issues before expensive full validation
3. **In-Memory Optimization**: Leverage tmpfs and memory rendering for maximum speed
4. **Docker Isolation**: Consistent, reproducible test environments
5. **Incremental Processing**: Test only what changed when possible

### Performance vs Completeness Trade-off

```
Speed ←→ Completeness
Syntax → Memory → Quick → Full
 <1s      <3s     <10s   <60s
```

## Test Tier Architecture

### Tier 1: Syntax Validation (<1s)

**Purpose**: Ultra-fast syntax checking without any rendering

- **Command**: `hugo build --dryRun --quiet`
- **Docker Service**: `syntax-checker` (64MB limit)
- **Validates**: Template syntax, YAML/TOML parsing, Go template compilation
- **Output**: Error/success only, no artifacts generated
- **Cache Strategy**: None (fastest possible execution)

**Use Cases**:

- Pre-commit hooks
- Real-time editor validation
- Initial CI pipeline gate

### Tier 2: Memory Rendering (<3s)

**Purpose**: In-memory content validation with tmpfs optimization

- **Command**: `hugo build --destination /tmp/hugo-memory`
- **Docker Service**: `memory-renderer` (256MB limit)
- **Storage**: tmpfs mount for ultra-fast I/O
- **Validates**: Content rendering, template execution, shortcodes, cross-references
- **Output**: Memory-only validation results
- **Cache Strategy**: Memory-only, no persistent storage

**Technical Implementation**:

```yaml
tmpfs:
  - /tmp/hugo-memory:size=128m,noatime
```

**Use Cases**:

- Development workflow validation
- Content author feedback
- Template development testing

### Tier 3: Quick Tests (<10s)

**Purpose**: Incremental validation of changed files only

- **Command**: `hugo build --destination public-quick`
- **Docker Service**: `quick-tester` (512MB limit)
- **Git Integration**: Uses `git diff` to identify changed files
- **Validates**: Changed content, affected templates, asset pipeline
- **Output**: Minimal build artifacts for validation
- **Cache Strategy**: Incremental with git-aware invalidation

**Change Detection Logic**:

```bash
git diff --name-only HEAD~1 HEAD | grep -E '\.(md|html|css|js|toml)$'
```

**Use Cases**:

- Feature branch validation
- Pull request checks
- Continuous integration for individual commits

### Tier 4: Full Validation (<60s)

**Purpose**: Complete site validation with production settings

- **Command**: `hugo build --environment production --minify --gc`
- **Docker Service**: `full-validator` (1GB limit)
- **Validates**: Complete site build, SEO, performance, accessibility
- **Output**: Full production-ready site
- **Cache Strategy**: Optimized persistent caching

**Use Cases**:

- Main branch validation
- Release preparation
- Deployment readiness checks
- Performance regression testing

## Docker Compose Orchestration

### Service Architecture

```
┌─────────────────┐    ┌─────────────────┐
│   hugo-dev      │    │ syntax-checker  │
│   (Development) │    │   (Tier 1)      │
│   Port: 1313    │    │   64MB          │
└─────────────────┘    └─────────────────┘

┌─────────────────┐    ┌─────────────────┐
│ memory-renderer │    │  quick-tester   │
│   (Tier 2)      │    │   (Tier 3)      │
│   256MB + tmpfs │    │   512MB         │
└─────────────────┘    └─────────────────┘

┌─────────────────┐    ┌─────────────────┐
│ full-validator  │    │ test-monitor    │
│   (Tier 4)      │    │ (Monitoring)    │
│   1GB           │    │ Port: 9100      │
└─────────────────┘    └─────────────────┘
```

### Network Isolation

- **Hugo Network**: Development server access
- **Test Network**: Isolated test execution (internal only)
- **Monitoring**: Performance metrics collection

### Volume Strategy

```yaml
Caching Volumes:
├── hugo-dev-cache      # Development server cache
├── hugo-cache-quick    # Quick test incremental cache
└── hugo-cache-full     # Full validation cache

Tmpfs Mounts:
└── /tmp/hugo-memory    # In-memory rendering (128MB)
```

## In-Memory Rendering Strategy

### Tmpfs Optimization

**Benefits**:

- Zero disk I/O for rendered content
- RAM-speed file operations
- Automatic cleanup on container termination
- No persistent storage requirements

**Configuration**:

```yaml
tmpfs:
  - /tmp/hugo-memory:size=128m,noatime
```

**Memory Management**:

- 128MB tmpfs allocation
- 256MB total container limit
- Automatic overflow protection
- Real-time memory monitoring

### Content Processing Pipeline

```
Source Files → Template Engine → tmpfs → Validation
     ↓              ↓              ↓         ↓
  Git Repo     Hugo Processor   Memory FS   Results
```

## Caching Architecture

### Multi-Level Caching Strategy

#### Level 1: Git-Aware Incremental

- **Strategy**: Track file changes via git
- **Storage**: Named Docker volumes with checksums
- **Invalidation**: Content modifications, template changes

#### Level 2: Memory Optimization  

- **Strategy**: In-memory rendering for development
- **Storage**: tmpfs mounts for ultra-fast I/O
- **Lifecycle**: Per-test-run cleanup

#### Level 3: Persistent Build Cache

- **Strategy**: Reuse Hugo's internal caches
- **Storage**: Docker volumes for persistence
- **Cleanup**: Weekly automatic cleanup of stale entries

### Cache Hit Ratio Optimization

```
Target Cache Performance:
├── Git-aware incremental: >90% hit ratio
├── Memory operations: 100% hit ratio (tmpfs)
└── Persistent build cache: >80% hit ratio
```

## Performance Monitoring

### Real-Time Metrics Collection

- **Container Resource Usage**: CPU, Memory, I/O
- **Hugo Build Performance**: Build time, page count, asset processing
- **Cache Efficiency**: Hit ratios, invalidation patterns
- **Test Execution**: Duration, success rates, failure patterns

### Performance SLA Enforcement

```yaml
Performance Targets:
├── syntax_tier:    "<1s (target: 800ms)"
├── memory_tier:    "<3s (target: 2s)"  
├── quick_tier:     "<10s (target: 8s)"
└── full_tier:      "<60s (target: 45s)"
```

### Alerting Thresholds

- Performance degradation >20% from baseline
- Memory limit violations
- Cache efficiency drops <70%
- Test failure rate >5%

## CI/CD Integration Patterns

### GitHub Actions Integration

```yaml
Trigger Strategy:
├── Every Push:        syntax_tier
├── Pull Request:      memory_tier + quick_tier  
├── Feature Branch:    quick_tier
└── Main Branch:       all_tiers
```

### Development Workflow Integration

```yaml
Development Events:
├── File Save:         syntax_tier
├── Git Commit:        quick_tier
├── Branch Push:       memory_tier + quick_tier
└── Pre-merge:         full_tier
```

### Parallel Execution Strategy

- Tiers 1-2 run in parallel for immediate feedback
- Tier 3 triggers only after Tiers 1-2 pass
- Tier 4 runs independently for comprehensive validation
- Monitoring runs continuously across all tiers

## Troubleshooting and Diagnostics

### Common Performance Issues

1. **Memory Tier Slow**: Check tmpfs allocation and container limits
2. **Cache Inefficiency**: Monitor git-aware invalidation patterns
3. **Docker Performance**: Verify volume mount strategies
4. **Build Timeouts**: Analyze Hugo build complexity and content size

### Diagnostic Commands

```bash
# Check tier performance
docker-compose --profile test exec syntax-checker time hugo build --dryRun

# Monitor memory usage
docker stats jt-memory-renderer

# Cache analysis
docker-compose --profile test exec quick-tester du -sh /var/cache/hugo

# Full system diagnostics
docker-compose --profile monitoring up test-monitor
```

### Health Check Integration

- Container health monitoring
- Service dependency validation
- Resource utilization alerts
- Automated recovery procedures

## Migration and Rollout Strategy

### Phase 1: Syntax and Memory Tiers (Week 1)

- Implement basic Docker setup
- Configure syntax validation
- Establish memory rendering with tmpfs

### Phase 2: Incremental Testing (Week 2)

- Add git-aware change detection
- Implement quick test tier
- Integrate with existing CI/CD

### Phase 3: Full Validation (Week 3)

- Complete full-tier implementation
- Performance optimization
- Monitoring and alerting setup

### Phase 4: Production Deployment (Week 4)

- Full integration testing
- Documentation completion
- Team training and adoption

This architecture provides a robust, scalable foundation for Hugo static site testing that balances speed, accuracy, and resource efficiency while maintaining the isolation and reproducibility benefits of containerized testing.
