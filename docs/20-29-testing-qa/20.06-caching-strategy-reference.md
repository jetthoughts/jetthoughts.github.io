# Caching Strategy
**Multi-Level Caching for Optimal Hugo Test Performance**

## Caching Architecture Overview

The test architecture implements a sophisticated three-tier caching system designed to maximize performance while maintaining accuracy and isolation across different test scenarios.

### Cache Hierarchy
```
┌─────────────────────────────────────────────────────────────┐
│                    Cache Hierarchy                          │
└─────────────────────────────────────────────────────────────┘

Level 1: In-Memory/tmpfs (Ultra-Fast)
├── tmpfs mounts: /tmp/hugo-memory (128MB)
├── Container memory buffers: 64MB-1GB per tier
├── Hugo internal caches: Disabled for memory tier
└── Persistence: None (ephemeral per test run)

Level 2: Git-Aware Incremental (Smart)
├── Change detection: git diff --name-only HEAD~1 HEAD
├── Scope filtering: Content, templates, assets, config
├── Cache invalidation: File modification-based
└── Storage: Named Docker volumes with checksums

Level 3: Persistent Build Cache (Long-term)
├── Hugo module cache: /var/cache/hugo/modules
├── Asset processing cache: /var/cache/hugo/_gen
├── Template compilation cache: Hugo internal
└── Lifecycle: Persistent across sessions, weekly cleanup
```

## Level 1: In-Memory Caching (Memory Tier)

### Tmpfs Configuration
```yaml
# Ultra-fast memory-based filesystem
tmpfs_configuration:
  mount_point: /tmp/hugo-memory
  size_limit: 128MB
  mount_options: "noatime,rw,nodev,nosuid,size=128m"
  
  performance_characteristics:
    read_speed: "RAM speed (GB/s)"
    write_speed: "RAM speed (GB/s)"
    latency: "<1ms"
    iops: "Unlimited"
    
  use_cases:
    - "Memory tier validation"
    - "Development hot reload"
    - "Template debugging"
    - "Content preview"
```

### Container Memory Management
```yaml
memory_allocation:
  syntax_tier:
    container_limit: "64MB"
    hugo_cache: "disabled"
    working_memory: "32MB"
    buffer_size: "16MB"
    
  memory_tier:
    container_limit: "256MB"
    tmpfs_allocation: "128MB"
    hugo_processing: "64MB"
    system_overhead: "32MB"
    buffer_size: "32MB"
    
  quick_tier:
    container_limit: "512MB"
    cache_allocation: "256MB"
    hugo_processing: "128MB"
    build_artifacts: "96MB"
    buffer_size: "32MB"
    
  full_tier:
    container_limit: "1GB"
    cache_allocation: "512MB"
    hugo_processing: "256MB"
    build_artifacts: "192MB"
    buffer_size: "64MB"
```

### Memory Optimization Techniques
```yaml
optimization_strategies:
  hugo_configuration:
    # Disable expensive features for memory tier
    disable_git_info: true
    disable_build_stats: true
    disable_unused_kinds: ["RSS", "sitemap", "robotsTXT"]
    
  template_optimization:
    # Reduce memory footprint
    cache_templates: false
    parallel_processing: limited
    resource_fingerprinting: disabled
    
  content_processing:
    # Optimize for speed over features
    image_processing: disabled
    shortcode_caching: disabled
    taxonomy_processing: minimal
```

## Level 2: Git-Aware Incremental Caching

### Change Detection Strategy
```bash
#!/bin/bash
# Git-aware change detection logic

detect_changes() {
    local base_commit="${1:-HEAD~1}"
    local current_commit="${2:-HEAD}"
    
    # Get all changed files
    local all_changes=$(git diff --name-only "$base_commit" "$current_commit")
    
    # Filter relevant file types
    local content_changes=$(echo "$all_changes" | grep -E '\.(md|markdown)$' || true)
    local template_changes=$(echo "$all_changes" | grep -E '\.html$' || true)
    local asset_changes=$(echo "$all_changes" | grep -E '\.(css|scss|js|ts)$' || true)
    local config_changes=$(echo "$all_changes" | grep -E '\.(toml|yaml|yml|json)$' || true)
    
    # Determine impact scope
    if [[ -n "$config_changes" ]]; then
        echo "full_rebuild_required"
    elif [[ -n "$template_changes" ]]; then
        echo "template_rebuild_required"
    elif [[ -n "$asset_changes" ]]; then
        echo "asset_rebuild_required"
    elif [[ -n "$content_changes" ]]; then
        echo "content_rebuild_required"
    else
        echo "no_rebuild_required"
    fi
    
    # Store change metadata
    cat > /tmp/change_metadata.json << EOF
{
    "base_commit": "$base_commit",
    "current_commit": "$current_commit",
    "total_changes": $(echo "$all_changes" | wc -l),
    "content_changes": $(echo "$content_changes" | wc -l),
    "template_changes": $(echo "$template_changes" | wc -l),
    "asset_changes": $(echo "$asset_changes" | wc -l),
    "config_changes": $(echo "$config_changes" | wc -l),
    "files": [
        $(echo "$all_changes" | sed 's/^/"/; s/$/",/' | sed '$s/,$//')
    ]
}
EOF
}
```

### Cache Invalidation Rules
```yaml
invalidation_strategies:
  content_changes:
    triggers:
      - "*.md file modifications"
      - "frontmatter updates"
      - "image additions/removals"
    
    invalidation_scope:
      - "Affected content pages only"
      - "Related taxonomy pages"
      - "RSS feeds and sitemaps"
    
    cache_preservation:
      - "Template compilation cache"
      - "Asset processing cache"
      - "Unchanged content pages"
  
  template_changes:
    triggers:
      - "Layout file modifications"
      - "Partial template updates"
      - "Shortcode changes"
    
    invalidation_scope:
      - "All pages using affected templates"
      - "Template compilation cache"
      - "Rendered output cache"
    
    cache_preservation:
      - "Asset processing cache"
      - "Module download cache"
      - "Unchanged template cache"
  
  asset_changes:
    triggers:
      - "CSS/SCSS modifications"
      - "JavaScript updates"
      - "Image optimizations"
    
    invalidation_scope:
      - "Asset processing pipeline"
      - "CSS/JS bundle cache"
      - "Image optimization cache"
    
    cache_preservation:
      - "Template compilation cache"
      - "Content rendering cache"
      - "Module cache"
  
  configuration_changes:
    triggers:
      - "hugo.toml modifications"
      - "config.yaml updates"
      - "Module configuration changes"
    
    invalidation_scope:
      - "Complete cache invalidation"
      - "Full rebuild required"
    
    cache_preservation:
      - "Downloaded modules (selective)"
```

### Checksum-Based Validation
```yaml
checksum_strategy:
  file_tracking:
    algorithm: "SHA-256"
    tracked_extensions: [".md", ".html", ".css", ".js", ".toml", ".yaml"]
    checksum_storage: "Docker volume labels"
    
  validation_process:
    pre_build:
      - "Calculate checksums for all tracked files"
      - "Compare with stored checksums in cache"
      - "Identify changed files requiring rebuild"
      
    post_build:
      - "Update stored checksums"
      - "Tag cache volumes with new checksums"
      - "Prune obsolete cache entries"
    
  cache_hit_optimization:
    unchanged_files: "Skip processing entirely"
    partial_changes: "Process only affected dependencies"
    dependency_tracking: "Build dependency graph"
```

## Level 3: Persistent Build Cache

### Hugo Cache Categories
```yaml
hugo_internal_caches:
  modules:
    description: "Downloaded Hugo modules and dependencies"
    location: "/var/cache/hugo/modules"
    persistence: "Long-term (weeks to months)"
    size_estimate: "50-200MB"
    invalidation: "Module version changes"
    
  assets:
    description: "Processed assets (CSS, JS, images)"
    location: "/var/cache/hugo/_gen"
    persistence: "Medium-term (days to weeks)"
    size_estimate: "100-500MB"
    invalidation: "Asset file modifications"
    
  getjson:
    description: "Remote JSON data fetching cache"
    location: "/var/cache/hugo/getjson"
    persistence: "Short-term (hours to days)"
    size_estimate: "1-10MB"
    invalidation: "TTL-based"
    
  getcsv:
    description: "Remote CSV data fetching cache"
    location: "/var/cache/hugo/getcsv"  
    persistence: "Short-term (hours to days)"
    size_estimate: "1-10MB"
    invalidation: "TTL-based"
    
  images:
    description: "Image processing and optimization cache"
    location: "/var/cache/hugo/images"
    persistence: "Long-term (weeks to months)"
    size_estimate: "200MB-2GB"
    invalidation: "Source image modifications"
```

### Cache Volume Configuration
```yaml
docker_volumes:
  development_cache:
    name: "jt-hugo-dev-cache"
    size_limit: "2GB"
    backup_strategy: "None (development only)"
    cleanup_schedule: "Daily"
    
  quick_test_cache:
    name: "jt-hugo-cache-quick"
    size_limit: "1GB"
    backup_strategy: "Weekly snapshots"
    cleanup_schedule: "Weekly"
    retention_policy: "30 days"
    
  full_test_cache:
    name: "jt-hugo-cache-full"
    size_limit: "4GB"
    backup_strategy: "Daily snapshots"
    cleanup_schedule: "Monthly"
    retention_policy: "90 days"
    
  shared_modules:
    name: "jt-hugo-modules"
    size_limit: "500MB"
    backup_strategy: "Weekly snapshots"
    cleanup_schedule: "Monthly"
    retention_policy: "180 days"
```

### Cache Warming Strategy
```bash
#!/bin/bash
# Cache warming for optimal performance

warm_caches() {
    local tier="$1"
    
    case "$tier" in
        "development")
            # Pre-warm development cache
            docker-compose --profile dev run --rm hugo-dev \
                hugo build --destination /dev/null --quiet
            ;;
        
        "quick")
            # Pre-warm quick test cache with recent changes
            docker-compose --profile quick run --rm quick-tester \
                hugo build --destination /tmp/warm-cache --quiet
            ;;
        
        "full")
            # Pre-warm full validation cache
            docker-compose --profile full run --rm full-validator \
                hugo build --destination /tmp/warm-cache --environment production --quiet
            ;;
        
        "all")
            # Warm all caches in sequence
            warm_caches "development"
            warm_caches "quick"  
            warm_caches "full"
            ;;
    esac
    
    echo "Cache warming completed for tier: $tier"
}

# Schedule cache warming
warm_caches "all"
```

## Cache Performance Monitoring

### Metrics Collection
```yaml
performance_metrics:
  cache_hit_ratios:
    git_aware_incremental:
      target: ">90%"
      measurement: "unchanged_files / total_files"
      alert_threshold: "<70%"
      
    hugo_module_cache:
      target: ">95%"
      measurement: "cached_modules / total_modules"
      alert_threshold: "<80%"
      
    asset_processing_cache:
      target: ">85%"
      measurement: "cached_assets / total_assets"
      alert_threshold: "<60%"
  
  cache_efficiency:
    build_time_reduction:
      target: ">60%"
      measurement: "cached_build_time / clean_build_time"
      baseline: "Clean build performance"
      
    memory_utilization:
      target: "<80%"
      measurement: "peak_memory / allocated_memory"
      alert_threshold: ">90%"
      
    storage_efficiency:
      target: "<50%"
      measurement: "cache_size / project_size"
      cleanup_threshold: ">75%"
```

### Monitoring Commands
```bash
#!/bin/bash
# Cache monitoring utilities

monitor_cache_performance() {
    echo "=== Cache Performance Report ==="
    
    # Docker volume usage
    echo "Volume Usage:"
    docker system df -v | grep -E "(jt-hugo|hugo)"
    
    # Cache hit ratios (estimated)
    echo -e "\nEstimated Cache Performance:"
    
    # Git-aware cache efficiency
    local total_files=$(find . -name "*.md" -o -name "*.html" | wc -l)
    local changed_files=$(git diff --name-only HEAD~10 HEAD | wc -l)
    local cache_hit_ratio=$(( (total_files - changed_files) * 100 / total_files ))
    echo "Git-aware cache hit ratio: ${cache_hit_ratio}%"
    
    # Docker cache efficiency
    docker images | grep hugo | awk '{total+=$7} END {print "Docker image cache: " total/1024/1024 "MB"}'
    
    echo -e "\nCache Volume Details:"
    docker volume inspect jt-hugo-cache-quick jt-hugo-cache-full 2>/dev/null | \
        jq -r '.[] | "\(.Name): \(.Mountpoint) (\(.Labels))"'
}

analyze_cache_bottlenecks() {
    echo "=== Cache Bottleneck Analysis ==="
    
    # Measure build times with and without cache
    echo "Testing clean build performance..."
    docker-compose --profile full down --volumes
    time docker-compose --profile full run --rm full-validator > /tmp/clean_build.log 2>&1
    local clean_time=$(grep "real" /tmp/clean_build.log | awk '{print $2}')
    
    echo "Testing cached build performance..."
    time docker-compose --profile full run --rm full-validator > /tmp/cached_build.log 2>&1
    local cached_time=$(grep "real" /tmp/cached_build.log | awk '{print $2}')
    
    echo "Performance comparison:"
    echo "  Clean build: $clean_time"
    echo "  Cached build: $cached_time"
    
    # Calculate efficiency
    local efficiency=$(echo "$cached_time $clean_time" | awk '{printf "%.1f", (1 - $1/$2) * 100}')
    echo "  Cache efficiency: ${efficiency}%"
}
```

## Cache Maintenance and Optimization

### Automated Cleanup
```yaml
cleanup_schedules:
  daily_maintenance:
    schedule: "0 2 * * *"  # 2 AM daily
    tasks:
      - "Remove unused Docker volumes"
      - "Clean temporary build artifacts"
      - "Prune unused images"
      - "Rotate log files"
    
  weekly_optimization:
    schedule: "0 3 * * 0"  # 3 AM Sunday
    tasks:
      - "Defragment cache volumes"
      - "Update cache checksums"
      - "Optimize cache allocation"
      - "Performance analysis report"
    
  monthly_deep_clean:
    schedule: "0 4 1 * *"  # 4 AM first of month
    tasks:
      - "Full cache rebuild"
      - "Volume space reclamation"
      - "Performance baseline update"
      - "Cache strategy review"
```

### Cache Optimization Scripts
```bash
#!/bin/bash
# Cache optimization utilities

optimize_cache_allocation() {
    echo "Optimizing cache allocation based on usage patterns..."
    
    # Analyze cache usage patterns
    local hugo_cache_usage=$(docker exec $(docker-compose --profile full ps -q full-validator) \
        du -sh /var/cache/hugo 2>/dev/null | cut -f1)
    
    local build_cache_usage=$(docker volume inspect jt-hugo-build-full | \
        jq -r '.[0].Mountpoint' | xargs du -sh 2>/dev/null | cut -f1)
    
    echo "Current cache usage:"
    echo "  Hugo internal cache: $hugo_cache_usage"
    echo "  Build artifact cache: $build_cache_usage"
    
    # Suggest optimizations
    if [[ $(echo $hugo_cache_usage | grep -o '[0-9]*') -gt 500 ]]; then
        echo "Recommendation: Increase Hugo cache allocation"
    fi
    
    if [[ $(echo $build_cache_usage | grep -o '[0-9]*') -gt 1000 ]]; then
        echo "Recommendation: Clean build artifact cache"
    fi
}

validate_cache_integrity() {
    echo "Validating cache integrity..."
    
    # Check for corrupted cache entries
    docker-compose --profile test run --rm syntax-checker \
        hugo build --dryRun --quiet 2>&1 | grep -i error || echo "✓ No cache corruption detected"
    
    # Verify cache permissions
    docker-compose --profile test run --rm memory-renderer \
        ls -la /var/cache/hugo 2>/dev/null | grep -q "^d" && echo "✓ Cache permissions valid"
    
    # Test cache accessibility
    docker-compose --profile test run --rm quick-tester \
        test -w /var/cache/hugo && echo "✓ Cache write access confirmed"
}
```

This comprehensive caching strategy ensures optimal performance across all test tiers while maintaining data integrity and providing intelligent cache management based on actual usage patterns and change detection.