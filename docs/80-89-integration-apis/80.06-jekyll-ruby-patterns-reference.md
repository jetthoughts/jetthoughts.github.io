# Jekyll-Specific Ruby Patterns Reference

**Comprehensive guide to Jekyll Ruby patterns for Hugo compatibility and migration support**

## 📚 Overview

This document provides comprehensive Jekyll-specific Ruby patterns that enable Hugo sites to maintain Jekyll compatibility, support migration scenarios, and leverage Jekyll ecosystem tools where beneficial.

**Purpose**: Maximize reusability between Jekyll and Hugo workflows
**Scope**: JT Site Hugo project with Jekyll compatibility layers
**Authority**: Extends global Ruby standards for Jekyll-specific use cases

**Extends Global References**:
- **`/knowledge/80.01-ruby-development-standards.md`** - Core Ruby standards
- **`/knowledge/80.02-rails-framework-guidelines.md`** - Rails patterns
- **`/knowledge/80.03-ruby-testing-methodology.md`** - Ruby TDD methodology
- **`docs/80.05-ruby-development-hugo-integration.md`** - Hugo + Ruby integration

## 🔄 Jekyll to Hugo Migration Patterns

### Frontmatter Compatibility Layer
```ruby
# frozen_string_literal: true

# Jekyll frontmatter compatibility module
module JekyllCompatibility
  # Convert Jekyll frontmatter to Hugo-compatible format
  def self.normalize_frontmatter(jekyll_frontmatter)
    hugo_frontmatter = jekyll_frontmatter.dup

    # Jekyll date format → Hugo date format
    if jekyll_frontmatter["date"]
      hugo_frontmatter["date"] = normalize_date_format(jekyll_frontmatter["date"])
    end

    # Jekyll categories → Hugo taxonomies
    if jekyll_frontmatter["category"] || jekyll_frontmatter["categories"]
      categories = extract_categories(jekyll_frontmatter)
      hugo_frontmatter["categories"] = categories
      hugo_frontmatter.delete("category")
    end

    # Jekyll tags → Hugo tags (already compatible)
    if jekyll_frontmatter["tags"]
      hugo_frontmatter["tags"] = Array(jekyll_frontmatter["tags"])
    end

    # Jekyll layout → Hugo layout
    if jekyll_frontmatter["layout"]
      hugo_frontmatter["layout"] = jekyll_frontmatter["layout"]
    end

    hugo_frontmatter
  end

  private

    def self.normalize_date_format(date_value)
      case date_value
      when String
        Date.parse(date_value).strftime("%Y-%m-%dT%H:%M:%S%:z")
      when Date
        date_value.strftime("%Y-%m-%dT%H:%M:%S%:z")
      when Time
        date_value.strftime("%Y-%m-%dT%H:%M:%S%:z")
      else
        date_value
      end
    end

    def self.extract_categories(frontmatter)
      categories = []
      categories << frontmatter["category"] if frontmatter["category"]
      categories.concat(Array(frontmatter["categories"])) if frontmatter["categories"]
      categories.uniq
    end
end

# Usage example
jekyll_post_frontmatter = {
  "title" => "My Blog Post",
  "date" => "2025-01-15",
  "category" => "programming",
  "tags" => ["ruby", "hugo", "jekyll"],
  "layout" => "post"
}

hugo_compatible = JekyllCompatibility.normalize_frontmatter(jekyll_post_frontmatter)
# Result: Hugo-compatible frontmatter with proper date format and taxonomy structure
```

### Jekyll Liquid Template Compatibility
```ruby
# frozen_string_literal: true

# Jekyll Liquid template pattern compatibility
module JekyllLiquidPatterns
  # Common Jekyll Liquid patterns and their Hugo equivalents
  LIQUID_TO_HUGO_PATTERNS = {
    # Jekyll site variables
    "{{ site.title }}" => "{{ .Site.Title }}",
    "{{ site.description }}" => "{{ .Site.Params.description }}",
    "{{ site.url }}" => "{{ .Site.BaseURL }}",
    "{{ site.posts }}" => "{{ range .Site.RegularPages }}",

    # Jekyll page variables
    "{{ page.title }}" => "{{ .Title }}",
    "{{ page.date }}" => "{{ .Date }}",
    "{{ page.url }}" => "{{ .Permalink }}",
    "{{ page.content }}" => "{{ .Content }}",

    # Jekyll post variables
    "{{ post.title }}" => "{{ .Title }}",
    "{{ post.date }}" => "{{ .Date }}",
    "{{ post.url }}" => "{{ .Permalink }}",

    # Jekyll loops
    "{% for post in site.posts %}" => "{{ range .Site.RegularPages }}",
    "{% endfor %}" => "{{ end }}",

    # Jekyll conditionals
    "{% if page.title %}" => "{{ if .Title }}",
    "{% endif %}" => "{{ end }}",

    # Jekyll includes
    "{% include header.html %}" => "{{ partial \"header.html\" . }}",
    "{% include_relative file.md %}" => "{{ readFile \"file.md\" | markdownify }}"
  }.freeze

  # Convert Jekyll Liquid patterns to Hugo shortcodes
  def self.convert_liquid_to_hugo_shortcodes(content)
    converted_content = content.dup

    LIQUID_TO_HUGO_PATTERNS.each do |jekyll_pattern, hugo_pattern|
      converted_content.gsub!(jekyll_pattern, hugo_pattern)
    end

    converted_content
  end

  # Generate Jekyll compatibility warnings
  def self.analyze_jekyll_liquid_usage(content)
    warnings = []

    # Check for unsupported Jekyll patterns
    unsupported_patterns = [
      /\{\%\s*highlight\s+\w+\s*\%\}/, # Jekyll highlight tag
      /\{\{\s*paginator\.\w+\s*\}\}/, # Jekyll paginator
      /\{\%\s*post_url\s+[\w-]+\s*\%\}/, # Jekyll post_url tag
    ]

    unsupported_patterns.each_with_index do |pattern, index|
      if content.match?(pattern)
        warnings << {
          type: "unsupported_pattern",
          pattern: pattern.source,
          suggestion: get_hugo_alternative(index)
        }
      end
    end

    warnings
  end

  private

    def self.get_hugo_alternative(pattern_index)
      case pattern_index
      when 0
        "Use Hugo syntax highlighting: {{< highlight ruby >}} code {{< /highlight >}}"
      when 1
        "Use Hugo pagination: {{ range .Paginator.Pages }}"
      when 2
        "Use Hugo ref shortcode: {{< ref \"post-name.md\" >}}"
      else
        "Check Hugo documentation for equivalent pattern"
      end
    end
end
```

### Jekyll Plugin Compatibility Layer
```ruby
# frozen_string_literal: true

# Jekyll plugin compatibility for Hugo integration
module JekyllPluginCompatibility
  # Common Jekyll plugins and Hugo alternatives
  PLUGIN_ALTERNATIVES = {
    "jekyll-sitemap" => {
      hugo_equivalent: "Built-in sitemap generation",
      configuration: "enableRobotsTXT = true in config.toml",
      notes: "Hugo generates sitemaps automatically"
    },
    "jekyll-feed" => {
      hugo_equivalent: "RSS template",
      configuration: "Create layouts/_default/rss.xml",
      notes: "Hugo can generate RSS feeds with custom templates"
    },
    "jekyll-seo-tag" => {
      hugo_equivalent: "Custom partial templates",
      configuration: "Create partials/seo.html",
      notes: "Hugo allows custom SEO implementations via templates"
    },
    "jekyll-paginate" => {
      hugo_equivalent: "Built-in pagination",
      configuration: "paginate = 10 in config.toml",
      notes: "Hugo has built-in pagination support"
    },
    "jekyll-archives" => {
      hugo_equivalent: "Taxonomy templates",
      configuration: "Use taxonomy layouts and list pages",
      notes: "Hugo taxonomies provide similar archive functionality"
    }
  }.freeze

  # Analyze Jekyll _config.yml for plugin usage
  def self.analyze_jekyll_plugins(config_content)
    analysis = {
      found_plugins: [],
      hugo_alternatives: [],
      migration_notes: []
    }

    # Parse plugins section
    plugins_match = config_content.match(/^plugins:\s*\n((?:\s*-\s*.+\n?)*)/m)
    return analysis unless plugins_match

    plugins_section = plugins_match[1]
    plugin_names = plugins_section.scan(/^\s*-\s*(.+)$/).flatten

    plugin_names.each do |plugin|
      analysis[:found_plugins] << plugin

      if PLUGIN_ALTERNATIVES.key?(plugin)
        alternative = PLUGIN_ALTERNATIVES[plugin]
        analysis[:hugo_alternatives] << {
          jekyll_plugin: plugin,
          hugo_solution: alternative[:hugo_equivalent],
          configuration: alternative[:configuration],
          notes: alternative[:notes]
        }
      else
        analysis[:migration_notes] << {
          plugin: plugin,
          status: "no_direct_equivalent",
          recommendation: "Research Hugo community plugins or custom implementation"
        }
      end
    end

    analysis
  end

  # Generate migration guide for Jekyll plugins
  def self.generate_plugin_migration_guide(jekyll_config_path)
    return "Jekyll _config.yml not found" unless File.exist?(jekyll_config_path)

    config_content = File.read(jekyll_config_path)
    analysis = analyze_jekyll_plugins(config_content)

    guide = []
    guide << "# Jekyll Plugin Migration Guide\n"

    if analysis[:found_plugins].any?
      guide << "## Found Jekyll Plugins\n"
      analysis[:found_plugins].each do |plugin|
        guide << "- #{plugin}"
      end
      guide << ""
    end

    if analysis[:hugo_alternatives].any?
      guide << "## Hugo Alternatives\n"
      analysis[:hugo_alternatives].each do |alt|
        guide << "### #{alt[:jekyll_plugin]} → #{alt[:hugo_solution]}"
        guide << "**Configuration**: #{alt[:configuration]}"
        guide << "**Notes**: #{alt[:notes]}"
        guide << ""
      end
    end

    if analysis[:migration_notes].any?
      guide << "## Manual Migration Required\n"
      analysis[:migration_notes].each do |note|
        guide << "### #{note[:plugin]}"
        guide << "**Status**: #{note[:status]}"
        guide << "**Recommendation**: #{note[:recommendation]}"
        guide << ""
      end
    end

    guide.join("\n")
  end
end
```

## 🏗️ Jekyll Directory Structure Compatibility

### Jekyll to Hugo Directory Mapping
```ruby
# frozen_string_literal: true

# Jekyll to Hugo directory structure mapping
module JekyllDirectoryMapping
  DIRECTORY_MAPPING = {
    # Content directories
    "_posts" => "content/posts",
    "_drafts" => "content/drafts",
    "_pages" => "content",
    "assets" => "assets",
    "images" => "static/images",

    # Template directories
    "_layouts" => "layouts",
    "_includes" => "layouts/partials",
    "_sass" => "assets/scss",

    # Data directories
    "_data" => "data",

    # Configuration
    "_config.yml" => "config.toml", # Note: format conversion needed

    # Generated directories (should be ignored in Hugo)
    "_site" => "public" # Hugo equivalent of Jekyll build output
  }.freeze

  # Convert Jekyll directory structure to Hugo
  def self.map_jekyll_path_to_hugo(jekyll_path)
    DIRECTORY_MAPPING.each do |jekyll_dir, hugo_dir|
      if jekyll_path.start_with?(jekyll_dir)
        return jekyll_path.sub(jekyll_dir, hugo_dir)
      end
    end

    # Return original path if no mapping found
    jekyll_path
  end

  # Analyze Jekyll site structure
  def self.analyze_jekyll_structure(site_root)
    analysis = {
      jekyll_directories: [],
      hugo_equivalents: [],
      migration_required: [],
      migration_notes: []
    }

    Dir.entries(site_root).each do |entry|
      next if entry.start_with?(".")
      full_path = File.join(site_root, entry)
      next unless File.directory?(full_path)

      if DIRECTORY_MAPPING.key?(entry)
        analysis[:jekyll_directories] << entry
        analysis[:hugo_equivalents] << {
          jekyll: entry,
          hugo: DIRECTORY_MAPPING[entry],
          migration_type: get_migration_type(entry)
        }
      else
        analysis[:migration_required] << entry
      end
    end

    analysis
  end

  private

    def self.get_migration_type(jekyll_directory)
      case jekyll_directory
      when "_posts", "_drafts", "_pages"
        "content_migration"
      when "_layouts", "_includes"
        "template_migration"
      when "_data"
        "data_migration"
      when "_sass"
        "asset_migration"
      when "_config.yml"
        "configuration_migration"
      else
        "manual_migration"
      end
    end
end
```

## 📝 Jekyll Content Pattern Migration

### Jekyll Post Pattern to Hugo
```ruby
# frozen_string_literal: true

# Jekyll post patterns for Hugo compatibility
module JekyllPostPatterns
  # Jekyll post filename pattern: YYYY-MM-DD-title.md
  JEKYLL_POST_PATTERN = /^(\d{4})-(\d{2})-(\d{2})-(.*)\.(md|markdown)$/

  # Convert Jekyll post filename to Hugo format
  def self.convert_post_filename(jekyll_filename)
    match = jekyll_filename.match(JEKYLL_POST_PATTERN)
    return jekyll_filename unless match

    year, month, day, title, extension = match.captures

    # Hugo can use the same pattern or organize by year/month
    {
      hugo_flat: jekyll_filename, # Hugo supports Jekyll filename pattern
      hugo_organized: "#{year}/#{month}/#{title}.#{extension}", # Organized by date
      date_extracted: "#{year}-#{month}-#{day}",
      title_extracted: title.gsub("-", " ").downcase
    }
  end

  # Process Jekyll post content for Hugo
  def self.process_jekyll_post_content(content)
    # Split frontmatter and content
    parts = content.split(/^---\s*\n/, 3)
    return content if parts.length < 3

    frontmatter_yaml = parts[1]
    post_content = parts[2]

    # Parse frontmatter
    frontmatter = YAML.safe_load(frontmatter_yaml) || {}

    # Convert Jekyll-specific frontmatter to Hugo
    hugo_frontmatter = JekyllCompatibility.normalize_frontmatter(frontmatter)

    # Process content for Hugo compatibility
    hugo_content = JekyllLiquidPatterns.convert_liquid_to_hugo_shortcodes(post_content)

    # Reconstruct with Hugo-compatible frontmatter
    hugo_yaml = hugo_frontmatter.to_yaml.sub(/^---\n/, "")

    "---\n#{hugo_yaml}---\n#{hugo_content}"
  end

  # Batch process Jekyll posts for Hugo migration
  def self.migrate_jekyll_posts(jekyll_posts_dir, hugo_content_dir)
    migration_results = {
      processed: [],
      errors: [],
      warnings: []
    }

    jekyll_post_files = Dir.glob("#{jekyll_posts_dir}/*.{md,markdown}")

    jekyll_post_files.each do |jekyll_file|
      begin
        filename = File.basename(jekyll_file)
        content = File.read(jekyll_file)

        # Convert filename
        filename_info = convert_post_filename(filename)

        # Process content
        hugo_content = process_jekyll_post_content(content)

        # Determine Hugo file path
        hugo_file_path = File.join(hugo_content_dir, "posts", filename_info[:hugo_flat])

        # Create directory if needed
        FileUtils.mkdir_p(File.dirname(hugo_file_path))

        # Write Hugo version
        File.write(hugo_file_path, hugo_content)

        migration_results[:processed] << {
          jekyll_file: jekyll_file,
          hugo_file: hugo_file_path,
          filename_conversion: filename_info
        }

        # Check for Liquid pattern warnings
        liquid_warnings = JekyllLiquidPatterns.analyze_jekyll_liquid_usage(content)
        if liquid_warnings.any?
          migration_results[:warnings] << {
            file: filename,
            warnings: liquid_warnings
          }
        end

      rescue StandardError => e
        migration_results[:errors] << {
          file: jekyll_file,
          error: e.message
        }
      end
    end

    migration_results
  end
end
```

## 🧪 Jekyll Testing Patterns for Hugo

### Jekyll Test Compatibility
```ruby
# frozen_string_literal: true

require "minitest/autorun"
require "yaml"

# Jekyll compatibility testing for Hugo integration
class JekyllCompatibilityTest < Minitest::Test
  def setup
    @jekyll_content_dir = "test/fixtures/jekyll_content"
    @hugo_content_dir = "content"
  end

  def test_jekyll_frontmatter_compatibility
    # Test Jekyll frontmatter converts to Hugo format
    jekyll_frontmatter = {
      "title" => "Test Post",
      "date" => "2025-01-15",
      "category" => "programming",
      "tags" => ["ruby", "hugo"]
    }

    hugo_frontmatter = JekyllCompatibility.normalize_frontmatter(jekyll_frontmatter)

    assert_equal "Test Post", hugo_frontmatter["title"]
    assert hugo_frontmatter["date"].match?(/\d{4}-\d{2}-\d{2}T/)
    assert_equal ["programming"], hugo_frontmatter["categories"]
    assert_equal ["ruby", "hugo"], hugo_frontmatter["tags"]
  end

  def test_jekyll_liquid_pattern_conversion
    # Test Jekyll Liquid patterns convert to Hugo
    jekyll_content = <<~CONTENT
      <h1>{{ site.title }}</h1>
      <p>{{ page.title }}</p>
      {% for post in site.posts %}
        <a href="{{ post.url }}">{{ post.title }}</a>
      {% endfor %}
    CONTENT

    hugo_content = JekyllLiquidPatterns.convert_liquid_to_hugo_shortcodes(jekyll_content)

    assert hugo_content.include?("{{ .Site.Title }}")
    assert hugo_content.include?("{{ .Title }}")
    assert hugo_content.include?("{{ range .Site.RegularPages }}")
    assert hugo_content.include?("{{ .Permalink }}")
  end

  def test_jekyll_post_filename_conversion
    # Test Jekyll post filename converts properly
    jekyll_filename = "2025-01-15-my-blog-post.md"

    conversion_info = JekyllPostPatterns.convert_post_filename(jekyll_filename)

    assert_equal jekyll_filename, conversion_info[:hugo_flat]
    assert_equal "2025/01/my-blog-post.md", conversion_info[:hugo_organized]
    assert_equal "2025-01-15", conversion_info[:date_extracted]
    assert_equal "my blog post", conversion_info[:title_extracted]
  end

  def test_jekyll_plugin_analysis
    # Test Jekyll plugin analysis
    jekyll_config = <<~YAML
      plugins:
        - jekyll-sitemap
        - jekyll-feed
        - jekyll-seo-tag
        - some-custom-plugin
    YAML

    analysis = JekyllPluginCompatibility.analyze_jekyll_plugins(jekyll_config)

    assert_includes analysis[:found_plugins], "jekyll-sitemap"
    assert_includes analysis[:found_plugins], "some-custom-plugin"

    sitemap_alt = analysis[:hugo_alternatives].find { |alt| alt[:jekyll_plugin] == "jekyll-sitemap" }
    assert_equal "Built-in sitemap generation", sitemap_alt[:hugo_solution]

    custom_note = analysis[:migration_notes].find { |note| note[:plugin] == "some-custom-plugin" }
    assert_equal "no_direct_equivalent", custom_note[:status]
  end

  def test_jekyll_directory_structure_mapping
    # Test Jekyll to Hugo directory mapping
    jekyll_paths = [
      "_posts/2025-01-15-test.md",
      "_layouts/default.html",
      "_includes/header.html",
      "_data/navigation.yml"
    ]

    jekyll_paths.each do |jekyll_path|
      hugo_path = JekyllDirectoryMapping.map_jekyll_path_to_hugo(jekyll_path)
      refute_equal jekyll_path, hugo_path, "#{jekyll_path} should be mapped to Hugo equivalent"
    end

    # Specific mapping tests
    assert_equal "content/posts/2025-01-15-test.md",
                 JekyllDirectoryMapping.map_jekyll_path_to_hugo("_posts/2025-01-15-test.md")
    assert_equal "layouts/partials/header.html",
                 JekyllDirectoryMapping.map_jekyll_path_to_hugo("_includes/header.html")
  end

  def test_complete_jekyll_post_migration
    # Integration test for complete Jekyll post processing
    jekyll_post_content = <<~CONTENT
      ---
      title: "My Jekyll Post"
      date: 2025-01-15
      category: programming
      tags: [ruby, jekyll, hugo]
      layout: post
      ---

      # Welcome to my post

      {{ site.title }} is great!

      {% for post in site.posts %}
        * [{{ post.title }}]({{ post.url }})
      {% endfor %}
    CONTENT

    hugo_content = JekyllPostPatterns.process_jekyll_post_content(jekyll_post_content)

    # Verify frontmatter conversion
    assert hugo_content.include?("title: My Jekyll Post")
    assert hugo_content.match?(/date: \d{4}-\d{2}-\d{2}T/)
    assert hugo_content.include?("categories:\n- programming")

    # Verify Liquid pattern conversion
    assert hugo_content.include?("{{ .Site.Title }}")
    assert hugo_content.include?("{{ range .Site.RegularPages }}")
    assert hugo_content.include?("{{ .Permalink }}")
  end
end
```

## 🔧 Jekyll Configuration Migration

### Jekyll _config.yml to Hugo config.toml
```ruby
# frozen_string_literal: true

# Jekyll configuration migration to Hugo
module JekyllConfigMigration
  # Common Jekyll config options and Hugo equivalents
  CONFIG_MAPPING = {
    "title" => "title",
    "description" => "params.description",
    "url" => "baseURL",
    "permalink" => "permalinks",
    "markdown" => "markup.goldmark",
    "highlighter" => "markup.highlight",
    "paginate" => "paginate",
    "timezone" => "timezone",
    "exclude" => "ignoreFiles",
    "gems" => "# Hugo uses themes instead",
    "plugins" => "# Hugo uses themes and shortcodes"
  }.freeze

  # Convert Jekyll _config.yml to Hugo config.toml
  def self.migrate_jekyll_config(jekyll_config_path)
    return "Jekyll _config.yml not found" unless File.exist?(jekyll_config_path)

    jekyll_config = YAML.safe_load(File.read(jekyll_config_path))
    hugo_config = []

    hugo_config << "# Hugo configuration migrated from Jekyll _config.yml"
    hugo_config << ""

    # Basic site configuration
    if jekyll_config["title"]
      hugo_config << "title = \"#{jekyll_config['title']}\""
    end

    if jekyll_config["url"]
      hugo_config << "baseURL = \"#{jekyll_config['url']}\""
    end

    if jekyll_config["description"]
      hugo_config << ""
      hugo_config << "[params]"
      hugo_config << "description = \"#{jekyll_config['description']}\""
    end

    # Pagination
    if jekyll_config["paginate"]
      hugo_config << ""
      hugo_config << "paginate = #{jekyll_config['paginate']}"
    end

    # Markup configuration
    if jekyll_config["markdown"] || jekyll_config["highlighter"]
      hugo_config << ""
      hugo_config << "[markup]"

      if jekyll_config["highlighter"]
        hugo_config << "  [markup.highlight]"
        hugo_config << "    style = \"github\""
        hugo_config << "    lineNos = true"
      end
    end

    # Plugin migration notes
    if jekyll_config["plugins"] || jekyll_config["gems"]
      plugins = jekyll_config["plugins"] || jekyll_config["gems"] || []
      unless plugins.empty?
        hugo_config << ""
        hugo_config << "# Jekyll plugins found - see migration guide:"
        plugins.each do |plugin|
          hugo_config << "# - #{plugin}"
        end
      end
    end

    hugo_config.join("\n")
  end
end
```

## 📋 Jekyll Integration Checklist

### Pre-Migration Validation
- [ ] Jekyll site structure analysis completed
- [ ] Jekyll plugin inventory and Hugo alternatives identified
- [ ] Jekyll content patterns documented
- [ ] Liquid template usage analyzed

### During Migration
- [ ] Jekyll frontmatter converted to Hugo format
- [ ] Jekyll Liquid patterns converted to Hugo templates
- [ ] Jekyll directory structure mapped to Hugo conventions
- [ ] Jekyll configuration migrated to Hugo config

### Post-Migration Testing
- [ ] All Jekyll posts render correctly in Hugo
- [ ] Jekyll-style URLs work with Hugo routing
- [ ] SEO metadata preserved during migration
- [ ] Jekyll plugin functionality replicated in Hugo
- [ ] Ruby test validation passes for Jekyll compatibility

---

**Jekyll Compatibility Status**: This reference enables Hugo sites to maintain Jekyll compatibility patterns while leveraging Hugo's enhanced performance and static site generation capabilities.